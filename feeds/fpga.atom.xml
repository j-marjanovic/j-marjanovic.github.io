<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>j-marjanovic.io - FPGA</title><link href="www.j-marjanovic.io/" rel="alternate"></link><link href="www.j-marjanovic.io/feeds/fpga.atom.xml" rel="self"></link><id>www.j-marjanovic.io/</id><updated>2020-09-06T16:00:00+02:00</updated><entry><title>Stratix V accelerator card from eBay, part 3</title><link href="www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-3.html" rel="alternate"></link><published>2020-09-06T16:00:00+02:00</published><updated>2020-09-06T16:00:00+02:00</updated><author><name>Jan Marjanovic</name></author><id>tag:None,2020-09-06:www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-3.html</id><summary type="html">&lt;p&gt;As mentioned in my &lt;a href="https://j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-2.html"&gt;previous blog post&lt;/a&gt;, the next step would be
to get the JTAG running in Quaruts. In this blog post I describe how I managed
to develop a library as an interface between the FPGA board and Quartus, and
demonstrate the developed interface to download the bitstream …&lt;/p&gt;</summary><content type="html">&lt;p&gt;As mentioned in my &lt;a href="https://j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-2.html"&gt;previous blog post&lt;/a&gt;, the next step would be
to get the JTAG running in Quaruts. In this blog post I describe how I managed
to develop a library as an interface between the FPGA board and Quartus, and
demonstrate the developed interface to download the bitstream and to debug
the Nios II soft-core processor.&lt;/p&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;h2&gt;HW overview&lt;/h2&gt;
&lt;p&gt;The Stratix V board contains a 4-pin USB port (with a non-standard connector),
to which an &lt;a href="https://www.ftdichip.com/Products/ICs/FT232H.htm"&gt;FT232H&lt;/a&gt; is
attached, containing &lt;em&gt;Multi-Protocol Synchronous Serial Engine (MPSSE)&lt;/em&gt; which
can be used to implement the JTAG protocol.&lt;/p&gt;
&lt;p&gt;I am a little bit surprised that the board includes the full JTAG programmer and
not only the 10-pin JTAG header, which can be then used by the developers on
their development setups. On the other hand, the cost of an FT232H is 2.70 EUR
on Mouser for a reel, which is negligible compared to the cost of the board. I
can also understand that having a JTAG debugger available on each board is
valuable when monitoring the operating conditions (e.g. transceiver link quality
with the
&lt;a href="https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/an/an605.pdf"&gt;EyeQ&lt;/a&gt;)
and to debug and investigate the synchronization issues between the servers in
the deployment.&lt;/p&gt;
&lt;p&gt;I was not able to find more information about this particular USB/JTAG
connection on the Open Compute Project website.&lt;/p&gt;
&lt;h2&gt;Quartus software suite&lt;/h2&gt;
&lt;p&gt;Intel® Quartus® provides several programs that are extremely useful for
development for Intel/Altera FPGAs.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Quartus Programmer&lt;/strong&gt; which, as the name suggests, allows
  programming/configuring the FPGA devices over the JTAG chain, and it can also
  program the non-volatile memories attached to the FPGAs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;System Console&lt;/strong&gt; provides "visibility into your system" - one can use JTAG
  to Avalon MM bridge to read and write the registers in the IPs, and
  &lt;em&gt;Transceiver Toolkit&lt;/em&gt; and &lt;em&gt;External Memory Interface Toolkits&lt;/em&gt; both greatly
  simplify the bringup and debug of transceivers and external memories&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SignalTap&lt;/strong&gt; is an embedded logic analyzer, useful for debugging the logic
  in hardware, with the input from real devices&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nios II Debugger&lt;/strong&gt; provides access to soft-core Nios II processor, and
  it can be used to download the programs, to debug them through GDB, and to
  obtain the output from the program over the &lt;em&gt;JTAG UART&lt;/em&gt; IP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To my knowledge OpenOCD does not provide all these features and Quartus also
does not seem to be able to interface to OpenOCD.&lt;/p&gt;
&lt;h2&gt;OpenOCD&lt;/h2&gt;
&lt;p&gt;Nonetheless, OpenOCD can be used to scan the JTAG chain, and confirm
that the FTDI really is connected to the JTAG port of the FPGA:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ openocd -f interface/ftdi/um232h.cfg -c &lt;span class="s2"&gt;&amp;quot;adapter_khz 100; transport select jtag; jtag newtap auto0 tap -irlen 10 -expected-id 0x029070dd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
Open On-Chip Debugger &lt;span class="m"&gt;0&lt;/span&gt;.10.0
Licensed under GNU GPL v2
For bug reports, &lt;span class="nb"&gt;read&lt;/span&gt;
    http://openocd.org/doc/doxygen/bugs.html
adapter speed: &lt;span class="m"&gt;100&lt;/span&gt; kHz
Info : clock speed &lt;span class="m"&gt;100&lt;/span&gt; kHz
Info : JTAG tap: auto0.tap tap/device found: 0x029070dd &lt;span class="o"&gt;(&lt;/span&gt;mfg: 0x06e &lt;span class="o"&gt;(&lt;/span&gt;Altera&lt;span class="o"&gt;)&lt;/span&gt;, part: 0x2907, ver: 0x0&lt;span class="o"&gt;)&lt;/span&gt;
Warn : gdb services need one or more targets defined
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This gives hope that at least on the HW side, integrating the board with Quartus
will be easy.&lt;/p&gt;
&lt;h1&gt;JTAG library&lt;/h1&gt;
&lt;p&gt;Some information on how to add a custom cable can be found on &lt;a href="https://forums.intel.com/s/question/0D50P00003yyL2bSAE/bemicro-and-programming-under-linux"&gt;Intel
forums&lt;/a&gt;.
At the startup, Quartus scans the &lt;code&gt;linux64&lt;/code&gt; folder (if running on 64-bit Linux)
and searches for the shared object files which start with the &lt;code&gt;libjtag_hw.&lt;/code&gt; The
shared object is then loaded, and a function called &lt;code&gt;get_supported_hardware&lt;/code&gt; is
called. This function returns a structure, containing function pointers for
various operations that the programmer and other utilities can perform.&lt;/p&gt;
&lt;p&gt;To understand this (undocumented) interface a little bit better, I first
implemented &lt;a href="https://github.com/j-marjanovic/jtag-quartus-ft232h/blob/master/src/jtag_hw_dummy.cpp"&gt;a library with a dummy JTAG TAP
controller&lt;/a&gt;.
This library can be copied or linked in the &lt;code&gt;linux64&lt;/code&gt; folder, and then used in
Quartus Programmer. The implementation of the JTAG pretends that it is a Stratix
V device (by having the same &lt;code&gt;IDCODE&lt;/code&gt;) and then discards all the bits which are
downloaded to the device. If somebody has too much time, one can easily extend
this to create a very complicated &lt;code&gt;.sof&lt;/code&gt; to &lt;code&gt;.rbf&lt;/code&gt; converter. Finally, the
dummy device fakes the status register to communicate that the &lt;code&gt;CONF_DONE&lt;/code&gt; is
high at the end of the programming. For debugging purposes, the library prints
extensive debug information over a UNIX socket.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A dummy JTAG device being programmed in Quartus Programmer" src="www.j-marjanovic.io/images/2020_fpga_card_part_3/jtag_dummy.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;Once this part in place, it is easy to imagine that combining the library
of the dummy JTAG and the HW-related part of the OpenOCD is not so complicated.
Since the OpenOCD is licensed under GPL v2, I have decided to re-use the code
for MPSSE and FT232H and to also license my library under the same license.&lt;/p&gt;
&lt;h2&gt;Downloading the bitstream&lt;/h2&gt;
&lt;p&gt;Here is the documentation of the first victory in this convoluted JTAG bring-up
process, the bitstream is successfully downloaded into the FPGA, and an LED on
the board is blinking, indicating a total success.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Stratix V being programmed over the on-board FT232H" src="www.j-marjanovic.io/images/2020_fpga_card_part_3/jtag_ft232h.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h2&gt;JTAG to Avalon&lt;/h2&gt;
&lt;p&gt;To check if all functions of the JTAG cable are working, I have prepared a small
IP (discussed below) and connected it to &lt;a href="https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug_embedded_ip.pdf"&gt;JTAG to Avalon Master
Bridge&lt;/a&gt;.
This IP provides access to the Avalon interconnect over &lt;strong&gt;System Console&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Shown here is a read of 12 words from a certain address in the Avalon MM memory
space:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="k"&gt;set&lt;/span&gt; jtag_master &lt;span class="k"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;lindex&lt;/span&gt; &lt;span class="k"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;get_service_paths&lt;/span&gt; master&lt;span class="k"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="k"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;devices&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;SGSMD5H&lt;span class="k"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;SGSMD5K1&lt;span class="o"&gt;|&lt;/span&gt;..&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;bus-instance&lt;span class="err"&gt;#&lt;/span&gt;OTMA FT232H&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;link&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;JTAG&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;110&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;132&lt;/span&gt; v1 &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;phy_0&lt;span class="o"&gt;/&lt;/span&gt;master
&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;open_service&lt;/span&gt; master &lt;span class="nv"&gt;$jtag_master&lt;/span&gt;

&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;master_read_32&lt;/span&gt; &lt;span class="nv"&gt;$jtag_master&lt;/span&gt; &lt;span class="mh"&gt;0x1000&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="nv"&gt;0xc10cc272&lt;/span&gt; &lt;span class="mh"&gt;0x00010000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x266ac4b1&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;master_read_32&lt;/span&gt; &lt;span class="nv"&gt;$jtag_master&lt;/span&gt; &lt;span class="mh"&gt;0x1000&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="nv"&gt;0xc10cc272&lt;/span&gt; &lt;span class="mh"&gt;0x00010000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x266ac4ac&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;master_read_32&lt;/span&gt; &lt;span class="nv"&gt;$jtag_master&lt;/span&gt; &lt;span class="mh"&gt;0x1000&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="nv"&gt;0xc10cc272&lt;/span&gt; &lt;span class="mh"&gt;0x00010000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x266ac4a8&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;master_read_32&lt;/span&gt; &lt;span class="nv"&gt;$jtag_master&lt;/span&gt; &lt;span class="mh"&gt;0x1000&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="nv"&gt;0xc10cc272&lt;/span&gt; &lt;span class="mh"&gt;0x00010000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x266ac4a3&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I will explain later what exactly are we seeing here, for now let's just accept
that &lt;em&gt;JTAG to Avalon bridge&lt;/em&gt; works, and it reads a magic number register
(&lt;code&gt;0xc10cc272&lt;/code&gt;), a version register (&lt;code&gt;0x00010000&lt;/code&gt;), and the &lt;code&gt;meas_clk[5]&lt;/code&gt; register
reports a value between 644531368 Hz and 644531377 Hz.&lt;/p&gt;
&lt;h2&gt;Nios II&lt;/h2&gt;
&lt;p&gt;For a final test, I wanted to see if I can download a program into the Nios II
instruction memory, run the program and observe the output over the JTAG UART
interface.&lt;/p&gt;
&lt;p&gt;Also here there were no obstacles with the home-made JTAG driver, and
I could successfully perform all tasks necessary to download and debug the
Nios II core, as also presented on the screenshot below.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A program being debugged over Nios II debugger over the on-board FT232H" src="www.j-marjanovic.io/images/2020_fpga_card_part_3/nios_debugger.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h1&gt;Clock&lt;/h1&gt;
&lt;p&gt;The board contains an &lt;a href="https://www.idt.com/us/en/document/dst/idt8n4q001-datasheet"&gt;IDT8N4Q001 programmable clock
oscillator&lt;/a&gt;, which
is most likely used to generate the clocks needed for 40 Gigabit Ethernet (e.g.
156.25 MHz) and maybe for other communication protocols on the QSFP slots. Since
none of the currently available resources
(&lt;a href="https://github.com/wirebond/catapult_v2_pikes_peak"&gt;wirebond/catapult_v2_pikes_peak&lt;/a&gt;
and &lt;a href="http://virtlab.occamlab.com/home/zapisnik/microsoft-catapult-v2"&gt;Microsoft's Catapult v2 (Pikes
Peak)&lt;/a&gt;)
mentions where the IDT is connected to FPGA, I had to find out this myself.&lt;/p&gt;
&lt;p&gt;The oscillator on my board has a code &lt;code&gt;2059&lt;/code&gt;, which according to &lt;a href="https://www.idt.com/us/en/document/mau/femtoclock-ng-ceramic-package-xo-and-vcxo-ordering-information"&gt;the document
from
IDT&lt;/a&gt;
produces 644.53125 MHz for all values of &lt;code&gt;FSEL&lt;/code&gt; in the default configuration.
This matches the previously measured frequency at the input &lt;code&gt;CLK_R_REFCLK5&lt;/code&gt;
(pins &lt;code&gt;T7&lt;/code&gt; and &lt;code&gt;T6&lt;/code&gt;).&lt;/p&gt;
&lt;h2&gt;Clock counter&lt;/h2&gt;
&lt;p&gt;I have written a small IP to measure the frequency of several clocks from a
known clock frequency. As a known frequency I have used the 125 MHz on-board
oscillator.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Clock-counter IP block diagram" src="www.j-marjanovic.io/images/2020_fpga_card_part_3/clock_counter.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;The clock-counter IP generates a strobe signal with a frequency of 0.5 Hz (i.e.
pulse width of 1 s). Each of the measured clocks counts with an independent
counter. When a transition of the strobe signal is detected, the counter value
is stored in a register (accessible on Avalon MM interface) and the counter
value is reset to 0. The counter then continuos counting, until the next
transition is detected and the same procedure is repeated.&lt;/p&gt;
&lt;p&gt;Since the counter is active for exactly a second (within a certain ppm range)
before it gets stored in a register, the value stored in the register is the
frequency of the measured clock, in Hertz.&lt;/p&gt;
&lt;p&gt;The clock-domain crossing for the registers is non-existent, the registers
are loaded from one clock (from the measured clock) and read from the Avalon
interface clocks. Since the register is updated only once per second (and
thus the possibility that we read during an update is quite low) and since
this is only used for diagnostics, not implementing a proper CDC can
be tolerated.&lt;/p&gt;
&lt;h2&gt;IDT driver&lt;/h2&gt;
&lt;p&gt;I prepared &lt;a href="https://github.com/j-marjanovic/otma-fpga-bringup/blob/25f084c1b9c3982f7a8b281c95cab5e36f978822/software/otma_bringup/src/IDT8NxQ001.c"&gt;a driver for the IDT
oscillator&lt;/a&gt;,
which provides:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a function to decode the bytes into a proper structure (can be used to inspect
  the current configuration),&lt;/li&gt;
&lt;li&gt;a function to encode the structure in bytes (can be used to generate the bytes
  to be written into the device),&lt;/li&gt;
&lt;li&gt;a function to configure all relevant fields (per channel) to obtain the
  desired frequency&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and some other functions.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/j-marjanovic/otma-fpga-bringup/blob/25f084c1b9c3982f7a8b281c95cab5e36f978822/software/otma_bringup/src/main.c"&gt;main
program&lt;/a&gt;
configures 4 different frequencies, selects one of the four, and then goes into a
loop where it prints the measured frequency once per second.&lt;/p&gt;
&lt;p&gt;Here is the output of the program:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="nl"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ident&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Oxcl0cc272&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x00010000&lt;/span&gt;
&lt;span class="n"&gt;IDT8NXQOO1&lt;/span&gt; &lt;span class="nl"&gt;config&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nl"&gt;MINT&lt;/span&gt;     &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;
  &lt;span class="nl"&gt;MFRAC&lt;/span&gt;    &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000&lt;/span&gt; &lt;span class="mo"&gt;000000&lt;/span&gt; &lt;span class="mo"&gt;000000&lt;/span&gt; &lt;span class="mo"&gt;00000&lt;/span&gt;
  &lt;span class="nl"&gt;N&lt;/span&gt;        &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;
  &lt;span class="nl"&gt;P&lt;/span&gt;        &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mo"&gt;00&lt;/span&gt;
  &lt;span class="nl"&gt;DSM_ENA&lt;/span&gt;  &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
  &lt;span class="nl"&gt;LF&lt;/span&gt;       &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="nl"&gt;CP&lt;/span&gt;       &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
  &lt;span class="nl"&gt;FSEL&lt;/span&gt;     &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="nl"&gt;nPLL_BYP&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="nl"&gt;ADC_ENA&lt;/span&gt;  &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;Finished&lt;/span&gt; &lt;span class="n"&gt;configuring&lt;/span&gt; &lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;oscillator&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;entering&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6250002&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;103430663&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250082&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250082&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250085&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250086&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250086&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250085&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250086&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250084&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250083&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250082&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250082&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250082&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250081&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250084&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We see that after the measurement has stabilized, we are receiving the clock
which we have configured, and we see that both the reference clock (125 MHz to
generate the strobe signal) and the measured clock have a low wander and a low
offset.&lt;/p&gt;
&lt;h1&gt;Conclusion and future plans&lt;/h1&gt;
&lt;p&gt;I have managed to prepare a setup that will allow me to develop and debug the
Stratix V FPGA directly from Quartus. I am satisfied that I could develop a
software solution and use the on-board FTDI chip, and I did not have to solder
wires for the JTAG to the board.&lt;/p&gt;
&lt;p&gt;With the access to useful tools in Quartus (e.g. SignalTap, Console, Nios II
debugger, Transceiver toolkit, ...) I believe bringing up the rest of the board
will be much easier.&lt;/p&gt;
&lt;p&gt;Finally, to validate that the library for the JTAG cable runs reliably, I have
used it to develop a small program that can configure the on-board oscillator
to a desired frequency, in my case 156.25 MHz. I plan to use this for a test
of the transceivers connected to the QSFP slots.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;All trademarks and registered trademarks are the property of their respective
owners.&lt;/p&gt;</content><category term="FPGA"></category></entry><entry><title>Stratix V accelerator card from eBay, part 2</title><link href="www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-2.html" rel="alternate"></link><published>2020-06-07T16:00:00+02:00</published><updated>2020-06-07T16:00:00+02:00</updated><author><name>Jan Marjanovic</name></author><id>tag:None,2020-06-07:www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-2.html</id><summary type="html">&lt;p&gt;In my previous blog post I have explored the FPGA card I have purchased on eBay,
and in this post I will present an adapter card which I have developed. The
adapter provides PCI Express connection between a normal card-edge slot and the
FPGA card, as well as the access …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In my previous blog post I have explored the FPGA card I have purchased on eBay,
and in this post I will present an adapter card which I have developed. The
adapter provides PCI Express connection between a normal card-edge slot and the
FPGA card, as well as the access to the I2C bus and some additional signals.&lt;/p&gt;
&lt;p&gt;To summarize my previous blog post, the FPGA card has a 160-pin Samtec
connector, providing power (12V), I2C bus for management, and a total of 16
lanes for PCI Express.&lt;/p&gt;
&lt;h1&gt;The adapter&lt;/h1&gt;
&lt;p&gt;To keep the cost down, I have tried to make the adapter as small as possible,
and at this point to only develop a proof-of-concept. On this first variant
of the adapter only connects one PCIe lane, and I plan a second variant where
all 8 or 16 lanes will be connected to the PCIe edge connector.&lt;/p&gt;
&lt;p&gt;The KiCad project for the adapter card is available on &lt;a href="https://github.com/j-marjanovic/ocs-tray-mezzanine-adapter"&gt;my
GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Shown in the image below are the relevant parts of the adapter card.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Block diagram of the adapter card" src="www.j-marjanovic.io/images/2020_fpga_card_part_2/otma.png" style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;To connect to the PCIe slot I have purchased one of those &lt;a href="https://lmgtfy.com/?q=bitcoin+pci+express+riser+card&amp;amp;t=i"&gt;Bitcoin mining riser
cards&lt;/a&gt;, which provide
connections between PCIe slot and a USB3 cable. Since there are a total of
4 PCIe reference clock inputs per OCS specification, I have distributed
the clock to all inputs using a dedicated IC. I have connected the management
I2C bus (&lt;code&gt;MEZZ_SDA&lt;/code&gt; and &lt;code&gt;MEZZ_SCL&lt;/code&gt;) to a header, which allows me to explore the
bus with a Raspberry Pi for example, as shown in the picture below.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Raspberry Pi connected to the management I2C bus" src="www.j-marjanovic.io/images/2020_fpga_card_part_2/adapter_rpi.jpg" style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h1&gt;I2C&lt;/h1&gt;
&lt;p&gt;Having a Raspberry Pi connected to the I2C bus, we can first explore the
present devices.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;i2cdetect&lt;/code&gt; we can find all devices which have acknowledged their I2C
address:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pi@raspberrypi:~ $ i2cdetect -y 1
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
40: -- -- -- -- -- -- -- -- -- -- -- -- 4c -- -- -- 
50: -- 51 -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
70: -- -- -- -- -- -- -- 77         
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We see the EEPROM at the address 0x51, and another two devices at addresses 0x4C
and 0x77 - I would assume that these are some kind of sensors and/or regulators.&lt;/p&gt;
&lt;h2&gt;IPMI FRU&lt;/h2&gt;
&lt;p&gt;We can now use the &lt;code&gt;i2cdump&lt;/code&gt; to dump the content of the EEPROM. As I have
expected, the EEPROM is used by the Baseboard Management Controller (or
something similar) and the content is compliant with &lt;a href="https://www.intel.com/content/dam/www/public/us/en/documents/product-briefs/platform-management-fru-document-rev-1-2-feb-2013.pdf"&gt;IPMI Platform Management
FRU Information Storage
Definition&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The following information are stored in the EEPROM:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ChassisArea:
  version: 1
  length: 32 bytes
  chassis type: Rack Mount Chassis
  part nr: X907370-001
  serial nr: (len 0)
  checksum: 146 (OK)
BoardArea:
  version: 1
  length: 64 bytes
  lang: 25
  mfg date: 2016-01-06 03:26
  mfgr: Microsoft
  prod_name: PPFPGA
  serial: OLJ60100194
  part: X900563-001
  file id: FRU 1.0
  checksum: 108 (OK)
ProductArea:
  version: 1
  length: 72 bytes
  mfgr: Microsoft
  prod_name: PPFPGA
  part_nr: X900563-001
  part_ver: 1.0
  part_sn: OLJ60100194
  asset_tag:
  file id: 1.0
  checksum: 241 (OK) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;From my understanding of the IPMI standard, the Chassis information should
not be present on this card:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A system can have multiple FRU Information Devices within a chassis, but only
one device should provide the Chassis Info Area. Thus, this area will
typically be absent from most FRU Information Devices.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;PCI Express&lt;/h1&gt;
&lt;p&gt;And finally, the most interesting and the most challenging part, the PCI Express
connection.&lt;/p&gt;
&lt;p&gt;I have plugged in the card, as shown on the image below and turned on the computer. &lt;/p&gt;
&lt;p&gt;&lt;img alt="PCIe connection over USB cable" src="www.j-marjanovic.io/images/2020_fpga_card_part_2/adapter_pcie.jpg" style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;And it works! Using &lt;code&gt;lspci&lt;/code&gt; command to list all the devices visible to the CPU,
one can also note the Microsoft card:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ lspci
00:00.0 Host bridge: Intel Corporation 2nd Generation Core Processor Family DRAM Controller (rev 09)
00:01.0 PCI bridge: Intel Corporation Xeon E3-1200/2nd Generation Core Processor Family PCI Express Root Port (rev 09)
00:02.0 VGA compatible controller: Intel Corporation 2nd Generation Core Processor Family Integrated Graphics Controller (rev 09)
00:16.0 Communication controller: Intel Corporation 6 Series/C200 Series Chipset Family MEI Controller #1 (rev 04)
00:16.2 IDE interface: Intel Corporation 6 Series/C200 Series Chipset Family IDE-r Controller (rev 04)
00:16.3 Serial controller: Intel Corporation 6 Series/C200 Series Chipset Family KT Controller (rev 04)
00:19.0 Ethernet controller: Intel Corporation 82579LM Gigabit Network Connection (Lewisville) (rev 04)
00:1a.0 USB controller: Intel Corporation 6 Series/C200 Series Chipset Family USB Enhanced Host Controller #2 (rev 04)
00:1b.0 Audio device: Intel Corporation 6 Series/C200 Series Chipset Family High Definition Audio Controller (rev 04)
00:1c.0 PCI bridge: Intel Corporation 6 Series/C200 Series Chipset Family PCI Express Root Port 1 (rev b4)
00:1c.4 PCI bridge: Intel Corporation 6 Series/C200 Series Chipset Family PCI Express Root Port 5 (rev b4)
00:1c.6 PCI bridge: Intel Corporation 6 Series/C200 Series Chipset Family PCI Express Root Port 7 (rev b4)
00:1d.0 USB controller: Intel Corporation 6 Series/C200 Series Chipset Family USB Enhanced Host Controller #1 (rev 04)
00:1e.0 PCI bridge: Intel Corporation 82801 PCI Bridge (rev a4)
00:1f.0 ISA bridge: Intel Corporation Q67 Express Chipset LPC Controller (rev 04)
00:1f.2 SATA controller: Intel Corporation 6 Series/C200 Series Chipset Family 6 port Desktop SATA AHCI Controller (rev 04)
00:1f.3 SMBus: Intel Corporation 6 Series/C200 Series Chipset Family SMBus Controller (rev 04)
03:00.0 Unassigned class [ff00]: Microsoft Corporation Device b100 (rev 01)
04:00.0 USB controller: NEC Corporation uPD720200 USB 3.0 Host Controller (rev 04)
05:03.0 FireWire (IEEE 1394): LSI Corporation FW322/323 [TrueFire] 1394a Controller (rev 70)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Using &lt;code&gt;lspci -vv&lt;/code&gt; to get more information, we see that the link is established
at 2.5 GT/s (probably too many connectors in series to go faster) and at
x1 width (as expected, since we only pass one lane through the USB cable):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo lspci -s 03:00 -vv
03:00.0 Unassigned class [ff00]: Microsoft Corporation Device b100 (rev 01)
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;PERR- INTx-
    Latency: 0, Cache Line Size: 64 bytes
    Interrupt: pin A routed to IRQ 11
    Region 0: Memory at fa000000 (32-bit, non-prefetchable) [size=16M]
    Region 2: Memory at fb000000 (32-bit, non-prefetchable) [size=1K]
    Capabilities: [50] MSI: Enable- Count=1/4 Maskable- 64bit+
        Address: 0000000000000000  Data: 0000
    Capabilities: [78] Power Management version 3
        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot-,D3cold-)
        Status: D0 NoSoftRst- PME-Enable- DSel=0 DScale=0 PME-
    Capabilities: [80] Express (v2) Endpoint, MSI 00
        DevCap: MaxPayload 256 bytes, PhantFunc 0, Latency L0s &amp;lt;64ns, L1 &amp;lt;1us
            ExtTag- AttnBtn- AttnInd- PwrInd- RBE+ FLReset- SlotPowerLimit 10.000W
        DevCtl: CorrErr- NonFatalErr- FatalErr- UnsupReq-
            RlxdOrd- ExtTag- PhantFunc- AuxPwr- NoSnoop+
            MaxPayload 128 bytes, MaxReadReq 128 bytes
        DevSta: CorrErr+ NonFatalErr- FatalErr- UnsupReq+ AuxPwr- TransPend-
        LnkCap: Port #1, Speed 8GT/s, Width x8, ASPM not supported
            ClockPM- Surprise- LLActRep- BwNot- ASPMOptComp+
        LnkCtl: ASPM Disabled; RCB 64 bytes Disabled- CommClk+
            ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
        LnkSta: Speed 2.5GT/s (downgraded), Width x1 (downgraded)
            TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-
        DevCap2: Completion Timeout: Range ABCD, TimeoutDis+, NROPrPrP-, LTR-
             10BitTagComp-, 10BitTagReq-, OBFF Not Supported, ExtFmt-, EETLPPrefix-
             EmergencyPowerReduction Not Supported, EmergencyPowerReductionInit-
             FRS-, TPHComp-, ExtTPHComp-
             AtomicOpsCap: 32bit- 64bit- 128bitCAS-
        DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis-, LTR-, OBFF Disabled
             AtomicOpsCtl: ReqEn-
        LnkCtl2: Target Link Speed: 8GT/s, EnterCompliance- SpeedDis-
             Transmit Margin: Normal Operating Range, EnterModifiedCompliance- ComplianceSOS-
             Compliance De-emphasis: -6dB
        LnkSta2: Current De-emphasis Level: -3.5dB, EqualizationComplete-, EqualizationPhase1-
             EqualizationPhase2-, EqualizationPhase3-, LinkEqualizationRequest-
    Capabilities: [100 v1] Virtual Channel
        Caps:   LPEVC=0 RefClk=100ns PATEntryBits=1
        Arb:    Fixed- WRR32- WRR64- WRR128-
        Ctrl:   ArbSelect=Fixed
        Status: InProgress-
        VC0:    Caps:   PATOffset=00 MaxTimeSlots=1 RejSnoopTrans-
            Arb:    Fixed- WRR32- WRR64- WRR128- TWRR128- WRR256-
            Ctrl:   Enable+ ID=0 ArbSelect=Fixed TC/VC=01
            Status: NegoPending- InProgress-
    Capabilities: [200 v1] Vendor Specific Information: ID=0000 Rev=0 Len=044 &amp;lt;?&amp;gt;
    Capabilities: [300 v1] Secondary PCI Express
        LnkCtl3: LnkEquIntrruptEn-, PerformEqu-
        LaneErrStat: 0
    Capabilities: [800 v1] Advanced Error Reporting
        UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
        UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
        UESvrt: DLP+ SDES+ TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-
        CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-
        CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+
        AERCap: First Error Pointer: 00, ECRCGenCap- ECRCGenEn- ECRCChkCap- ECRCChkEn-
            MultHdrRecCap- MultHdrRecEn- TLPPfxPres- HdrLogCap-
        HeaderLog: 00000000 00000000 00000000 00000000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Summary and outlook&lt;/h1&gt;
&lt;p&gt;The adapter card did its job and provided access to the I2C bus and a connection
to the PCI Express. I have managed to parse the content of the EEPROM (and
realize that there is nothing interesting there) and establish the PCIe
connection to the FPGA, as a first step of getting the hardware ready for custom
developments.&lt;/p&gt;
&lt;p&gt;Eventually I plan to develop a card with a wider PCIe link and get rid of the
USB cable setup.&lt;/p&gt;
&lt;p&gt;There were some mistakes on the adapter board (rotated Samtec connector, swapped
TX and RX on the USB connector) which I could work around, and serve as a lesson
to be more careful next time and double-check everything.&lt;/p&gt;
&lt;p&gt;As the next step, I would like to understand better how the JTAG chip works. I
know that it can be used with OpenOCD, but I would imagine that one can somehow
also make it talk to Quartus directly.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;All trademarks and registered trademarks are the property of their respective owners.&lt;/p&gt;</content><category term="FPGA"></category></entry><entry><title>Stratix V accelerator card from eBay</title><link href="www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay.html" rel="alternate"></link><published>2020-05-03T14:30:00+02:00</published><updated>2020-05-03T14:30:00+02:00</updated><author><name>Jan Marjanovic</name></author><id>tag:None,2020-05-03:www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay.html</id><summary type="html">&lt;p&gt;A couple of weeks ago &lt;a href="https://twitter.com/rombik_su"&gt;@rombik_su&lt;/a&gt; in a &lt;a href="https://twitter.com/rombik_su/status/1250382904074608642"&gt;Twitter
thread&lt;/a&gt; pointed out a
very cheap FPGA accelerator card on eBay. The board contains a proprietary
Samtec board-to-board connector, most likely carrying power, PCI Express, and
auxiliary signals (JTAG, IPMI to BMC, ...), two QSFP cages, DDR3 and a large
FPGA, hidden …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A couple of weeks ago &lt;a href="https://twitter.com/rombik_su"&gt;@rombik_su&lt;/a&gt; in a &lt;a href="https://twitter.com/rombik_su/status/1250382904074608642"&gt;Twitter
thread&lt;/a&gt; pointed out a
very cheap FPGA accelerator card on eBay. The board contains a proprietary
Samtec board-to-board connector, most likely carrying power, PCI Express, and
auxiliary signals (JTAG, IPMI to BMC, ...), two QSFP cages, DDR3 and a large
FPGA, hidden under the heatsink.&lt;/p&gt;
&lt;p&gt;Being passionate about everything FPGA-related, and with Coronavirus lockdown
limiting the number of fun things to do, I decided to purchase the board. An
evaluation kit of this kind can easily cost thousands, and 40 USD is a real
bargain.&lt;/p&gt;
&lt;h2&gt;Initial research&lt;/h2&gt;
&lt;p&gt;While waiting for the board to arrive, I did some initial investigation. The
description on eBay is quite cryptic. The title of the listing included all the
text from the labels on the board, including the label "AIRFLOW" indicating
the direction of the forced air through the board.&lt;/p&gt;
&lt;p&gt;One of the most fruitful clues was the label "Microsoft" on the board. It was
well-publicized a couple of years ago that Microsoft is using FPGAs to
accelerate Bing searches, and this might be one of the boards used in the
servers.&lt;/p&gt;
&lt;p&gt;Remembering that Microsoft went with Altera (now Intel PSG) and that this was
some years back, it is most likely that the card contains a Stratix V FPGA.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://www.microsoft.com/en-us/research/uploads/prod/2014/06/HC26.12.520-Recon-Fabric-Pulnam-Microsoft-Catapult.pdf"&gt;first
link&lt;/a&gt;
on Google (or should I have used Bing? would the FPGAs be aware that I am
looking for information about them?) for "microsoft catapult stratix v"
presented some conceptually similar cards, but not exactly the same.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/10/Cloud-Scale-Acceleration-Architecture.pdf"&gt;second
link&lt;/a&gt;,
however, presented the exact card which I have purchased:&lt;/p&gt;
&lt;p&gt;&lt;img alt="FPGA card, from A. Caulfield et al: A Cloud-Scale Acceleration Architecture" src="www.j-marjanovic.io/images/2020_fpga_card/img-002.jpg" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;&lt;small&gt;(from A. Caulfield et al: A Cloud-Scale Acceleration Architecture)&lt;/small&gt;&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;The paper also contains a block diagram highlighting the main components
of the board:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Block diagram, from A. Caulfield et al: A Cloud-Scale Acceleration Architecture" src="www.j-marjanovic.io/images/2020_fpga_card/block_diagram.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;&lt;small&gt;(from A. Caulfield et al: A Cloud-Scale Acceleration Architecture)&lt;/small&gt;&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;The paper also mentions "widely-used OpenCompute server" which could give out
some information about the pinout on the Samtec connector. Since there are
numerous formats for mezzanine cards standardized by the OpenCompute project,
and finding the matching one is not trivial, I decided to leave this task for
later.&lt;/p&gt;
&lt;p&gt;Further digging in the search results, I was also able to find &lt;a href="https://mspoweruser.com/microsoft-talks-about-the-project-that-helped-them-build-the-worlds-first-ai-supercomputer/"&gt;another photo&lt;/a&gt;
of the board with the heatsink removed.&lt;/p&gt;
&lt;p&gt;The marking on the FPGA are removed, but we already know that it is a Stratix V,
and some things were expected from previous documents, e.g. 5 DDR3 chips for
a combined of 9 chips for 72-bit DDR3 data width).&lt;/p&gt;
&lt;p&gt;What I found interesting in this picture is a Flash memory (Micron 25Q256) in
the top right corner, which means that the image for the FPGA is most likely
stored on the board and is not downloaded through the connector at the startup.
It is also possible that &lt;a href="https://www.intel.com/content/www/us/en/programmable/support/support-resources/support-centers/devices/cfg-index/cfg-via-protocol.html"&gt;Configuration via
Protocol&lt;/a&gt;
is used, and only the basic image is stored in the Flash.&lt;/p&gt;
&lt;h1&gt;Board overview&lt;/h1&gt;
&lt;p&gt;Then one day, the board finally arrives. The board matches the description
in the previously-mentioned article.&lt;/p&gt;
&lt;p&gt;A quick look at the board identifies the following components:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;160 pin Samtec SEARAY™ connector&lt;/li&gt;
&lt;li&gt;USB (FT232H, used as a JTAG interface)&lt;/li&gt;
&lt;li&gt;power entry (FDMS0310AS MOSFET, 0.01 Ohm resistor, unidentified IC with the markings "L536FCD")&lt;/li&gt;
&lt;li&gt;power converters (Enpirion® EN2342QI DC-DC converter)&lt;/li&gt;
&lt;li&gt;programmable oscillator (IDT8N4Q001)&lt;/li&gt;
&lt;li&gt;Flash memory for FPGA (Micron N25Q256A)&lt;/li&gt;
&lt;li&gt;I2C EEPROM (ST M24128-BW)&lt;/li&gt;
&lt;li&gt;DDR3 memory (SK hynix H5TC4G83BFR)&lt;/li&gt;
&lt;/ul&gt;
&lt;p style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="The board with annotated sections" src="www.j-marjanovic.io/images/2020_fpga_card/9560_annotated.jpg"&gt;&lt;/p&gt;
&lt;h1&gt;USB/JTAG&lt;/h1&gt;
&lt;p&gt;At this point, it was time to start experimenting with the board. The FT232H
seems to be powered from the USB BUS voltage: pin 1 of J3 is connected to pin 40
(VREGIN) of FT232H. This is why I decided to first start with the USB. With the
datasheet for FT232H it was trivial to determine the pin assignments on the
connector. I did not want to solder directly on the connector pins, as I would
like to make a proper cable in the future.&lt;/p&gt;
&lt;p style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="USB connection with signal annotations" src="www.j-marjanovic.io/images/2020_fpga_card/9570_annotated.jpg"&gt;&lt;/p&gt;
&lt;p&gt;After plugging the cable in the computer, the FT232H is recognized as "USB
Serial Converter":&lt;/p&gt;
&lt;p style="width:40%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="Driver information about the FT232H" src="www.j-marjanovic.io/images/2020_fpga_card/device_manager2.png"&gt;&lt;/p&gt;
&lt;h1&gt;Connector, 1st look&lt;/h1&gt;
&lt;p&gt;At this point I could start trying to reverse engineer the connector pinout. I
managed to figure out the following connections:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ground&lt;/li&gt;
&lt;li&gt;Input power: there are a couple of pins connected to the Drain of the large
    MOSFET. I also assume that the level is, as it is common for PCIe cards,
    12V.&lt;/li&gt;
&lt;li&gt;There are 16 pairs of AC-coupling capacitors near the connector. PCIe
    standard mandates capacitors on the TX side, so I assume this is PCIE_TX.
    Not knowing the exact lane numbering, I decided to enumerate them with
    letters instead of numbers.&lt;/li&gt;
&lt;li&gt;PCIe RX is TBD, but looking at unassigned pins a clear pattern is visible&lt;/li&gt;
&lt;li&gt;Some of the pins are connected to the circuit above the connector - I have
    annotated these pins, but right now I do not have a clear idea what is the
    purpose. I annotated those pins as AUX.&lt;/li&gt;
&lt;/ul&gt;
&lt;p style="width:100%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="Samtec connector with partial pinout, 1" src="www.j-marjanovic.io/images/2020_fpga_card/pinout_1.png"&gt;&lt;/p&gt;
&lt;h1&gt;Power&lt;/h1&gt;
&lt;p&gt;I have connected the 12V on the Drain side of the Q12 (FDMS0310AS), which has
also energized the PU12 and +12V pins on the Samtec connector. However, the
power consumption was only 3 mA, and the MOSFET was left closed.&lt;/p&gt;
&lt;p&gt;I could not find any information about PU12 (L536FCD). I assume it is some
kind of a current-limit protection, measuring the current through the 0.01 Ohm
shunt resistor and controlling the Gate pin of Q12.&lt;/p&gt;
&lt;p&gt;To literally bypass this problem, I have decided to also connect 12 V on the
other side of the Q12. This yielded some results; the power consumption raised
to 695 mA, which is what one would expect from such board, and the LEDs turned
on. &lt;/p&gt;
&lt;p style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="Power consumption" src="www.j-marjanovic.io/images/2020_fpga_card/fr_9586_size1024.jpg"&gt;&lt;/p&gt;
&lt;p&gt;On various points in the circuit I could also measure all the voltages one
would expect to find in such a circuit:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.5V on the Enpirion (PU16) output&lt;/li&gt;
&lt;li&gt;1.35 V on C406 (DDR3 voltage)&lt;/li&gt;
&lt;li&gt;0.674 V on C1005 (DDR3 termination voltage)&lt;/li&gt;
&lt;li&gt;2.5 V on C442 (periphery)&lt;/li&gt;
&lt;li&gt;3.3 V on QSFP capacitors&lt;/li&gt;
&lt;li&gt;0.9 V on C354 (FPGA core voltage)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Memories&lt;/h1&gt;
&lt;h2&gt;FPGA configuration memory&lt;/h2&gt;
&lt;p&gt;The heatsink covers the large part of the top side of the board including the
Flash memory for the FPGA configuration. One can, however, still reach the pins
8 and 9 (DQ1 and DQ2, respectively) with an oscilloscope probe.&lt;/p&gt;
&lt;p&gt;After the power is applied to the board, we can observe that the FPGA gets
programmed in roughly a second. This is above the 100 ms/200 ms limit required
by the PCIe standard, but in this custom form factor the value might be
different.&lt;/p&gt;
&lt;p&gt;DQ2 pin on N25Q256A:&lt;/p&gt;
&lt;p style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="Data from DQ2 pin after power up" src="www.j-marjanovic.io/images/2020_fpga_card/mem_top_left_pin.png"&gt;&lt;/p&gt;
&lt;p&gt;LEDs on the board are also driven by the FPGA and remain lit for a second until
the FPGA is not programmed, another indication that the FPGA gets configured
from the memory.&lt;/p&gt;
&lt;h2&gt;EEPROM&lt;/h2&gt;
&lt;p&gt;Another memory on the board is a small 128Kbit EEPROM, which probably stores MAC
addresses, serial numbers, and other similar information.&lt;/p&gt;
&lt;p&gt;Quite interestingly, SDA and SCL lines remain stuck low after some time.
Maybe the EEPROM is not used at all, or maybe there is some other part
of the circuit is keeping the EEPROM interface state machine in a reset.&lt;/p&gt;
&lt;p&gt;SDA pin on M24128-BW, SCL is very similar:&lt;/p&gt;
&lt;p style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="SDA pin on M24128-BW" src="www.j-marjanovic.io/images/2020_fpga_card/M24128_SDA.png"&gt;&lt;/p&gt;
&lt;h1&gt;Connector, 2nd look&lt;/h1&gt;
&lt;p&gt;With the board powered on, I could measure the voltage on the connector pins.
As expected, on 16 differential pairs I can sense a bias voltage of the PCIe
receivers, around 0.7 V.&lt;/p&gt;
&lt;p&gt;Some of the AUX pins have a slight bias, but this is probably caused by
pull-up resistors and other components. It would require more investigation
to fully understand the purpose of these pins.&lt;/p&gt;
&lt;p style="width:100%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="Samtec connector with partial pinout, 2" src="www.j-marjanovic.io/images/2020_fpga_card/pinout_2.png"&gt;&lt;/p&gt;
&lt;h1&gt;Components&lt;/h1&gt;
&lt;h2&gt;QSFP&lt;/h2&gt;
&lt;p&gt;Plugging in a QSFP cable only marginally increases the power consumption.
It is clear that the high-speed circuit is disabled, most likely because
of an internal register configuration and less likely because the cable
is "not compatible", i.e. the board parses the EEPROM and it does not enable
the high-speed circuit.&lt;/p&gt;
&lt;p&gt;Consumption from the 12V input:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;without the QSFP module inserted: 696.7 mA&lt;/li&gt;
&lt;li&gt;with the QSFP module inserted: 697.5 mA&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;IDT oscillator&lt;/h2&gt;
&lt;p&gt;IDT oscillator is producing 645 MHz clock.&lt;/p&gt;
&lt;h2&gt;DDR3&lt;/h2&gt;
&lt;p&gt;I have probed what I presume are the DDR3 termination resistors (on the bottom
side, on the other side of the 5th DDR3 component on the top) and observed
no switching activity. It seems that the DDR3 controller is kept in reset.&lt;/p&gt;
&lt;h1&gt;Outlook&lt;/h1&gt;
&lt;p&gt;The first bring-up session was quite successful; I have managed to turn on the
board without damaging it and figure out the basic pinout of the connector.&lt;/p&gt;
&lt;p&gt;For the next step, I plan to investigate the OpenCompute website if there exists
a document that would describe the pinout of the connector. Still left to be
determined are the reference clock and an enable signal from the connector.&lt;/p&gt;
&lt;p&gt;Eventually I plan to produce a small PCB that would allow plugging this board
in a normal PCIe card slot.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;All trademarks and registered trademarks are the property of their respective owners.&lt;/p&gt;</content><category term="FPGA"></category></entry></feed>