<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>j-marjanovic.io - FPGA</title><link href="www.j-marjanovic.io/" rel="alternate"></link><link href="www.j-marjanovic.io/feeds/fpga.atom.xml" rel="self"></link><id>www.j-marjanovic.io/</id><updated>2021-05-15T13:30:00+02:00</updated><entry><title>Stratix V accelerator card from eBay, part 7</title><link href="www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-7.html" rel="alternate"></link><published>2021-05-15T13:30:00+02:00</published><updated>2021-05-15T13:30:00+02:00</updated><author><name>Jan Marjanovic</name></author><id>tag:None,2021-05-15:www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-7.html</id><summary type="html">&lt;p&gt;The reverse engineering of the FPGA accelerator card from eBay is progressing
well and documenting the DDR3 interface was a huge step forward. However, there
is still one important part of the board which is not fully uncovered, the PCI
Express® interface.&lt;/p&gt;
&lt;h1&gt;Hardware&lt;/h1&gt;
&lt;h2&gt;Pikes Peak&lt;/h2&gt;
&lt;p&gt;Pikes Peak is a Stratix …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The reverse engineering of the FPGA accelerator card from eBay is progressing
well and documenting the DDR3 interface was a huge step forward. However, there
is still one important part of the board which is not fully uncovered, the PCI
Express® interface.&lt;/p&gt;
&lt;h1&gt;Hardware&lt;/h1&gt;
&lt;h2&gt;Pikes Peak&lt;/h2&gt;
&lt;p&gt;Pikes Peak is a Stratix® V-based FPGA accelerator conforming to &lt;a href="https://www.opencompute.org/documents/microsoft-ocs-v2-tray-mezzanine"&gt;Open CloudServer
OCS Tray Mezzanine
Specification&lt;/a&gt;.
It connects to the motherboard with a 160-pin connector which provides power,
management, and a 16-lane-wide PCIe interface. With the resistors on the
&lt;code&gt;PCIE_CFG_ID&lt;/code&gt;, Pikes Peak indicates 2 x8 bifurcation.&lt;/p&gt;
&lt;p&gt;I have explored the various details of this board in previous posts on my blog.
Important for today's discussion is &lt;a href="stratix-v-accelerator-card-from-ebay-part-2.html"&gt;the part
2&lt;/a&gt;, where using a &lt;a href="https://github.com/j-marjanovic/ocs-tray-mezzanine-adapter"&gt;custom HW
adapter&lt;/a&gt; I was able
to establish the connection between the PC and the FPGA using the factory image
on the board (stored in on-board Flash).&lt;/p&gt;
&lt;p&gt;The part number of the device (&lt;code&gt;5SGSD5&lt;/code&gt;) indicates that it contains &lt;a href="https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/hb/stratix-v/stx5_51001.pdf"&gt;one
PCIe hard IP block&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;At that time I have assumed that one link of 8 PCIe lanes is connected to
the PCIe hard IP block and that another x8 link is connected to 8 transceivers
on the other side of the device, maybe with the PCIe IP implemented in logic.
Later we will explore why this assumption is not correct.&lt;/p&gt;
&lt;h2&gt;Storey Peak&lt;/h2&gt;
&lt;p&gt;Storey Peak contains (roughly) the same components as Pikes Peak but in a
"normal" PCIe card form factor. For me, as a hobbyist who is not very keen on
designing custom HW and prefers to stay in the FPGA domain, this form factor is
much more convenient.&lt;/p&gt;
&lt;p&gt;I have presented the main components of this board in a series of tweets a
couple of weeks ago:&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet" align="center"&gt;&lt;a href="https://twitter.com/janmarjanovic/status/1383876145821589505"&gt;Tweet of janmarjanovic/1383876145821589505&lt;/a&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;p&gt;An attentive reader will note the difference between the PCIe devices IDs on
Storey Peak and Pikes Peak: Store Peak reports &lt;code&gt;0xb101&lt;/code&gt; while Pikes Peak reports
&lt;code&gt;0xb100&lt;/code&gt;.&lt;/p&gt;
&lt;h1&gt;First test&lt;/h1&gt;
&lt;p&gt;I have
&lt;a href="https://github.com/j-marjanovic/otma-fpga-bringup/commit/da95ff009cd1d9d0664b099894da73b6e59f4eae"&gt;instantiated&lt;/a&gt;
the &lt;em&gt;Avalon-MM Stratix V Hard IP for PCI Express&lt;/em&gt; and connected it to a couple
of peripherals (GPIO, System ID) to provide a minimal example for access
from the computer. I have also connected the Hard IP status interface to the
Nios II processor, which allows me to query the status of the PCIe link over the
JTAG. There is only 1 location where the PCIe lanes can be connected in a
normal &lt;code&gt;5SGSD5&lt;/code&gt; (annotated in light pink in the image below), so I connected the
PCIe lanes there.&lt;/p&gt;
&lt;p&gt;&lt;img alt="PCIe pin locations" src="www.j-marjanovic.io/images/2021_fpga_card_part_7/pcie_pins.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h2&gt;First test with Pikes Peak&lt;/h2&gt;
&lt;p&gt;Once everything was set up I have connected the Pikes Peak board through the x1
extender to one of the slots in my DELL PowerEdge R720.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Pikes Peak in a server" src="www.j-marjanovic.io/images/2021_fpga_card_part_7/pp_in_server.jpg" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;The "OTMA adapter" does not properly connect the reset pin to the Pikes Peak
connector, and I had to manually issue a reset command after power-up. Below
is the output from the CLI running on the Nios II processor in FPGA:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;init done

pp_sp_example &amp;gt; pcie status
pcie:
  id = 2c1e57a7
  version = 10000
  status.cur speed   = 0
  status.LTTSM state = 0
  status.lane act    = 0
  status.DL up       = 0

pp_sp_example &amp;gt; clks
Clock counter: ident = 0xc10cc272, version = 0x10000
Clock frequency [0] =  124.999 MHz
Clock frequency [1] =  644.531 MHz
Clock frequency [2] =   99.998 MHz
Clock frequency [3] =   99.998 MHz
Clock frequency [4] =    0.000 MHz
Clock frequency [5] =    0.000 MHz
Clock frequency [6] =    0.000 MHz
Clock frequency [7] =    0.000 MHz

pp_sp_example &amp;gt; pcie reset
pcie: asserting reset...
pcie: deasserted reset...
pcie: reset deasserted

pp_sp_example &amp;gt; pcie status
pcie:
  id = 2c1e57a7
  version = 10000
  status.cur speed   = 2
  status.LTTSM state = f
  status.lane act    = 1
  status.DL up       = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We see that clocks 2 and 3 are both 100 MHz, which indicates that the PCIe clock
distribution works correctly, and after the reset the link reports:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;current speed: 5 GT/s&lt;/strong&gt; - maximum supported by the IP in this configuration&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LTSSM state: L0&lt;/strong&gt; - this is the state in which the state machine should be&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lane active: 1&lt;/strong&gt; - as expected, the USB cable contains only one high-speed differential lane&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is all looks very promising; once the PC boots I am also able to get the
same information from the &lt;code&gt;lspci&lt;/code&gt; utility:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo lspci -s 03:00 -vv
03:00.0 Non-VGA unclassified device: Altera Corporation Stratix V (rev 01)
    Subsystem: Device 01a2:0001
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;PERR- INTx-
    Latency: 0, Cache Line Size: 64 bytes
    Interrupt: pin A routed to IRQ 15
    NUMA node: 0
    Region 0: Memory at df800000 (32-bit, non-prefetchable) [size=2M]
&amp;lt;...&amp;gt;
    Capabilities: [80] Express (v2) Endpoint, MSI 00
        DevCap: MaxPayload 128 bytes, PhantFunc 0, Latency L0s &amp;lt;64ns, L1 &amp;lt;1us
            ExtTag- AttnBtn- AttnInd- PwrInd- RBE+ FLReset- SlotPowerLimit 25.000W
        DevCtl: CorrErr- NonFatalErr+ FatalErr+ UnsupReq+
            RlxdOrd+ ExtTag- PhantFunc- AuxPwr- NoSnoop+
            MaxPayload 128 bytes, MaxReadReq 512 bytes
        DevSta: CorrErr+ NonFatalErr- FatalErr- UnsupReq- AuxPwr- TransPend-
        LnkCap: Port #1, Speed 5GT/s, Width x8, ASPM not supported
            ClockPM- Surprise- LLActRep- BwNot- ASPMOptComp+
        LnkCtl: ASPM Disabled; RCB 64 bytes Disabled- CommClk+
            ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
        LnkSta: Speed 5GT/s (ok), Width x1 (downgraded)
            TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-
&amp;lt;...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And finally, I can use &lt;code&gt;pcimem&lt;/code&gt; to read and write to the registers in the FPGA,
e.g. read system ID and timestamp and write to a GPIO pin:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo ./pcimem /sys/bus/pci/devices/0000:03:00.0/resource0 0x100000 w
/sys/bus/pci/devices/0000:03:00.0/resource0 opened.
Target offset is 0x100000, page size is 4096
mmap(0, 4096, 0x3, 0x1, 3, 0x100000)
PCI Memory mapped to address 0x7f3ecc8ba000.
0x100000: 0x01A20001

$ sudo ./pcimem /sys/bus/pci/devices/0000:03:00.0/resource0 0x100004 w
/sys/bus/pci/devices/0000:03:00.0/resource0 opened.
Target offset is 0x100004, page size is 4096
mmap(0, 4096, 0x3, 0x1, 3, 0x100004)
PCI Memory mapped to address 0x7f65b24b3000.
0x100004: 0x6097B8A9

$ sudo ./pcimem /sys/bus/pci/devices/0000:03:00.0/resource0 0x0 w 1
/sys/bus/pci/devices/0000:03:00.0/resource0 opened.
Target offset is 0x0, page size is 4096
mmap(0, 4096, 0x3, 0x1, 3, 0x0)
PCI Memory mapped to address 0x7fec6c0cc000.
0x0000: 0x00000000
Written 0x0001; readback 0x   1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The proverbial "blinky" is actually blinking and so far everything seems to be
working correctly.&lt;/p&gt;
&lt;h2&gt;First test with Storey Peak&lt;/h2&gt;
&lt;p&gt;Encouraged by the success with the Pikes Peak board and the adapter PCB, I have
installed the Storey Peak board instead. Compared to the Pikes Peak board and
the cable salad there, this one fits much nicer - both from purely esthetic as
well as thermal point-of-view.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Storey Peak in a server" src="www.j-marjanovic.io/images/2021_fpga_card_part_7/sp_in_server.jpg" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;And here I encountered an unpleasant surprise. Although the clocks are there,
the PCIe link can never reach the &lt;em&gt;L0&lt;/em&gt; state, i.e. the link never finishes
training.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pp_sp_example &amp;gt; pcie status
pcie:
  id = 2c1e57a7
  version = 10000
  status.cur speed   = 1
  status.LTTSM state = 1a
  status.lane act    = 8
  status.DL up       = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Intel® provides good &lt;a href="https://community.intel.com/t5/FPGA-Wiki/FTA-PCI-express/ta-p/735993"&gt;troubleshooting resources for the PCIe
link&lt;/a&gt;, and
I have decided to have a look at the PIPE interface to see the data exchange
between the FPGA and the CPU.&lt;/p&gt;
&lt;p&gt;&lt;img alt="TS1 ordered sets" src="www.j-marjanovic.io/images/2021_fpga_card_part_7/ts1.png" style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;We can decode the data received by the first two transceivers and obtain
the information from the &lt;a href="https://www.oreilly.com/library/view/pci-express-system/0321156307/0321156307_ch14lev1sec5.html"&gt;TS1 ordered sets&lt;/a&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;field&lt;/th&gt;
&lt;th align="left"&gt;xcvr 0&lt;/th&gt;
&lt;th align="left"&gt;xcvr 1&lt;/th&gt;
&lt;th&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;COM&lt;/td&gt;
&lt;td align="left"&gt;0xBC (K28.5)&lt;/td&gt;
&lt;td align="left"&gt;0xBC (K28.5)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Link #&lt;/td&gt;
&lt;td align="left"&gt;0x00&lt;/td&gt;
&lt;td align="left"&gt;0x00&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Lane #&lt;/td&gt;
&lt;td align="left"&gt;0x08&lt;/td&gt;
&lt;td align="left"&gt;0x09&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;N_FTS&lt;/td&gt;
&lt;td align="left"&gt;0x1E&lt;/td&gt;
&lt;td align="left"&gt;0x1E&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Rate ID&lt;/td&gt;
&lt;td align="left"&gt;0x0E&lt;/td&gt;
&lt;td align="left"&gt;0x0E&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;We see that the first transceiver receives lane number 8 and the second
transceiver receives lane number 9. At this point one can look again at the
board, and realize that the upper 8 lanes are connected to the PCIe Hard IP in
the FPGA.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Card with annotated FPGA" src="www.j-marjanovic.io/images/2021_fpga_card_part_7/annotated.jpg" style="width:70%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;This explains why we see lane 8 on the first transceiver, and also explains
why the link does not get established.&lt;/p&gt;
&lt;h2&gt;Storey Peak in a computer which supports bifurcation&lt;/h2&gt;
&lt;p&gt;Just for a test, I have plugged the Storey Peak card in a computer that
supports 2 x8 bifurcation on a x16 slot.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Bifurcation configuration" src="www.j-marjanovic.io/images/2021_fpga_card_part_7/server_bifurcation.png" style="width:50%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;We can see that in this configuration there are two PCIe endpoints presented:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ lspci
&amp;lt;...&amp;gt;
86:00.0 Unassigned class [ff00]: Microsoft Corporation Device b100 (rev 01)
87:00.0 Unassigned class [ff00]: Microsoft Corporation Device b101 (rev 01)
&amp;lt;...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And each of them supports a x8 link. It is theoretically possible that one of
the endpoints is implemented in FPGA logic, but we will later see that this
is not the case.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo lspci -s 86:00 -vv
86:00.0 Unassigned class [ff00]: Microsoft Corporation Device b100 (rev 01)
&amp;lt;...&amp;gt;
        LnkCap:    Port #1, Speed 8GT/s, Width x8, ASPM not supported, Exit Latency L0s &amp;lt;4us, L1 &amp;lt;1us
&amp;lt;...&amp;gt;
        LnkSta:    Speed 8GT/s, Width x8, TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-
&amp;lt;...&amp;gt;

$ sudo lspci -s 87:00 -vv
87:00.0 Unassigned class [ff00]: Microsoft Corporation Device b101 (rev 01)
&amp;lt;...&amp;gt;
        LnkCap:    Port #1, Speed 8GT/s, Width x8, ASPM not supported, Exit Latency L0s &amp;lt;4us, L1 &amp;lt;1us
&amp;lt;...&amp;gt;
        LnkSta:    Speed 8GT/s, Width x8, TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-
&amp;lt;...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Unfortunately the DELL R720 which I use in my homelab does not support PCIe
bifurcation.&lt;/p&gt;
&lt;h1&gt;Investigation&lt;/h1&gt;
&lt;p&gt;With some confusion regarding the assignment of PCIe lanes and the number of
hard IP blocks in this device, it is time to carefully check the presentation on
&lt;a href="https://indico.cern.ch/event/822126/contributions/3500184/attachments/1906428/3148591/Catapult_FastML_Fermilab_2019.pdf"&gt;Heterogeneous Computing @
Microsoft&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Shown on slide 14 is the screenshot from Quartus® Chip Planner. Comparing this
screenshot with the Chip Planner view for a "normal" device, we can note that
in the presentation there is an additional PCIe block, which is not present
in a normal device.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Comparison between the two devices" src="www.j-marjanovic.io/images/2021_fpga_card_part_7/msft_presentation.png" style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h2&gt;Web search&lt;/h2&gt;
&lt;p&gt;There were a couple of speculation on &lt;a href="https://twitter.com/rombik_su/status/1257741366144180226"&gt;Twitter by
@rombik_su&lt;/a&gt; and
&lt;a href="https://www.reddit.com/r/FPGA/comments/7g0f80/altera_part_lookup/"&gt;reddit&lt;/a&gt; on
what this part might be, and we can see that the last part of the code (reserved
for &lt;em&gt;Special order devices&lt;/em&gt;) contains &lt;strong&gt;AC&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet" align="center"&gt;&lt;a href="https://twitter.com/rombik_su/status/1257741366144180226"&gt;Tweet of rombik_su/1257741366144180226&lt;/a&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;p&gt;Searching for the full code (&lt;strong&gt;5SGSKF40I3LNAC&lt;/strong&gt;) also finds a &lt;a href="https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/pcn/pdn2007.pdf"&gt;PDN from
Intel&lt;/a&gt;
with a comment that the device is available "Upon Request, Please Contact Sales".&lt;/p&gt;
&lt;p&gt;There is also &lt;a href="https://community.intel.com/t5/Programmable-Devices/FA-request-of-3-PCS-FBGA-AJ000400T01-ALTERA-Mfr-P-N/td-p/1204542"&gt;a
thread&lt;/a&gt;
on the Intel forum by somebody from Quanta who has a problem with a post-production
check on this device.&lt;/p&gt;
&lt;h2&gt;Bitstream analysis&lt;/h2&gt;
&lt;p&gt;At this point it is pretty clear that this device is a custom part with 2 PCIe
Hard IPs. I was curious if I am able to find the evince of the second IP
in the bitstream.&lt;/p&gt;
&lt;p&gt;I have used the same approach as for the DDR3 controller: by changing one
variable at the time I was able to isolate the address in the JIC file which
corresponds to the individual PCIe IP parameter. By repeating this procedure I
was able to extract addresses for several parameters, especially interesting are
the ones that can be observed from the outside, such as vendor ID, device ID,
BAR type and size, ...&lt;/p&gt;
&lt;p&gt;After I have managed to find the location of several parameters, I have
extracted the values from the original JIC. As expected, one can easily
see Microsoft® vendor ID (&lt;code&gt;0x1414&lt;/code&gt;) and the device ID (&lt;code&gt;0xb100&lt;/code&gt;):&lt;/p&gt;
&lt;p&gt;&lt;img alt="Parameters extracted from the bitstream" src="www.j-marjanovic.io/images/2021_fpga_card_part_7/bitstream_extract.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;I have then taken the bits which correspond to the PCIe block on the left side
and performed a weighted autocorrelation on the bitstream. The procedure
and the result can be found in a Jupyter &lt;a href="https://github.com/j-marjanovic/otma-pin-re/blob/master/scripts/pcie_analysis/02_autocorrelation.ipynb"&gt;notebook&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;One can see that there is a strong peak very close to the original
configuration: the second configuration differs by just 1 bit. This is exactly
what one can expect since we know that the two endpoints have different device
IDs (&lt;code&gt;0xb100&lt;/code&gt; and &lt;code&gt;0xb101&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img alt="Auto-correlation of the original IP configuration" src="www.j-marjanovic.io/images/2021_fpga_card_part_7/auto_corr.png" style="width:70%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;With this we can confirm that there is a configuration for the second Hard IP
stored in the factory image in the on-board Flash.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;It is now clear that this board contains a custom part with two PCIe hard IP
blocks. Unfortunately, the block which is available in a normal
device is connected to the high lanes (lanes 8-15), and this requires at minimum
some support from the motherboard to be useful.&lt;/p&gt;
&lt;p&gt;There are several possibilities on how to proceed here:&lt;/p&gt;
&lt;h2&gt;Playing stupid method&lt;/h2&gt;
&lt;p&gt;I tried playing stupid and just instantiated two hard IPs in my design.
Quartus was (as expected), not so easily fooled:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Error message when two hard IPs are instantiated with a normal part" src="www.j-marjanovic.io/images/2021_fpga_card_part_7/2_ips.png" style="width:70%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h2&gt;Riser cable&lt;/h2&gt;
&lt;p&gt;One could take a x16 riser cable and resolder the wires to swap the two x8
connections on the connector. This will only provide 8 lanes, as the second
hard IP cannot be used (yet).&lt;/p&gt;
&lt;h2&gt;Upgrading my homelab server&lt;/h2&gt;
&lt;p&gt;Is somebody interested in buying a DELL PowerEdge R720? :)&lt;/p&gt;
&lt;h2&gt;Soft PCIe IP&lt;/h2&gt;
&lt;p&gt;One could think about developing a soft IP and connect it directly to the
transceivers. The development effort here would be enormous since Physical,
Data, and Transaction Layers need to be handled in the logic. On the other hand,
this could also be a great learning experience to get familiar with the lower
layers of protocol, which are usually handled by a dedicated PCIe block.
Additionally, one would have to use few advanced features of the transceiver
itself (rate change, 8b/10b and 128b/130b decoder, receiver detection, lane
bonding, ...).&lt;/p&gt;
&lt;h2&gt;Manipulating the bitstream&lt;/h2&gt;
&lt;p&gt;Since we have the configuration stored in the factory bitstream, one could
consider "pasting" this configuration on top of a normal bitstream. This
method does not seem user-friendly, and the main obstacle would be connecting
the user logic to the second (unknown) hard IP.&lt;/p&gt;
&lt;h2&gt;Unlocking the custom part in Quartus&lt;/h2&gt;
&lt;p&gt;The database for this custom part is either already integrated into Quartus or
it is delivered to the customer as a separate package (e.g. a DLL or a shared
object).&lt;/p&gt;
&lt;p&gt;If one &lt;code&gt;grep&lt;/code&gt;s for &lt;code&gt;5SGSMD5&lt;/code&gt; in the Quartus directory there is a library that
contains a couple of interesting strings:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ strings libddb_dstr.so | egrep &amp;#39;5SGSMD5&amp;#39;
&amp;lt;...&amp;gt;
5SGSMD5H3F35I3LNAA
&amp;lt;...&amp;gt;
5SGSMD5K3F40I3YY
&amp;lt;...&amp;gt;
5SGSMD5_MS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So far hard work and determination have paid off. It seems that continuing
to poke around Quartus libraries would be the right way ahead.&lt;/p&gt;
&lt;hr&gt;
&lt;div style="font-size: 80%;" &gt;
Intel, the Intel logo, Altera, Nios, Quartus and Stratix words and logos are
trademarks of Intel  Corporation  or  its subsidiaries  in  the  U.S.  and/or
other  countries.
&lt;/div&gt;

&lt;div style="font-size: 80%;" &gt;
Microsoft® is a registered trademark of Microsoft Corporation in the United
States and/or other countries.
&lt;/div&gt;

&lt;div style="font-size: 80%;" &gt;
PCI Express® and PCIe® are registered trademarks of PCI-SIG.
&lt;/div&gt;

&lt;div style="font-size: 80%;" &gt;
All trademarks and registered trademarks are the property of their respective owners.
&lt;/div&gt;&lt;script src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;</content><category term="FPGA"></category></entry><entry><title>Stratix V accelerator card from eBay, part 6</title><link href="www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-6.html" rel="alternate"></link><published>2021-02-28T13:00:00+01:00</published><updated>2021-02-28T13:00:00+01:00</updated><author><name>Jan Marjanovic</name></author><id>tag:None,2021-02-28:www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-6.html</id><summary type="html">&lt;p&gt;In my &lt;a href="./stratix-v-accelerator-card-from-ebay-part-5.html"&gt;last blog post&lt;/a&gt; I
have presented a method to extract the DDR3 pinout from the bitstream, obtained
from the on-board Flash. In this post I will use the information obtained from
the bitstream to instantiate a DDR3 memory controller and measure its
performance.&lt;/p&gt;
&lt;h1&gt;DDR3 SDRAM Controller with UniPHY …&lt;/h1&gt;</summary><content type="html">&lt;p&gt;In my &lt;a href="./stratix-v-accelerator-card-from-ebay-part-5.html"&gt;last blog post&lt;/a&gt; I
have presented a method to extract the DDR3 pinout from the bitstream, obtained
from the on-board Flash. In this post I will use the information obtained from
the bitstream to instantiate a DDR3 memory controller and measure its
performance.&lt;/p&gt;
&lt;h1&gt;DDR3 SDRAM Controller with UniPHY&lt;/h1&gt;
&lt;p&gt;Once the pinout was obtained from the bitstream and the DDR3 part number was
identified from the markings on the board, instantiating the DDR3 controller was
relatively straightforward. To speed up the development, I first started with
just only &lt;a href="https://github.com/j-marjanovic/otma-fpga-bringup/commit/ca66f8ec1a54b9ec2a499152ac7027b3861588ad"&gt;1 DDR3 chip (8-bit
width)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The first sign of the success were the LEDs indicating that the DDR3
initialization controller has finished its job and that the calibration
(of the delay chains) was successfully completed.&lt;/p&gt;
&lt;p&gt;&lt;img alt="LEDs indicating a success of the DDR3 controller initialization procedure" src="www.j-marjanovic.io/images/2021_fpga_card_part_6/ddr3_calib_done.jpg" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h1&gt;EMIF Debug Toolkit&lt;/h1&gt;
&lt;p&gt;As mentioned in &lt;a href="./stratix-v-accelerator-card-from-ebay-part-3.html"&gt;part 3&lt;/a&gt; of
this series, I have spent quite some time making the JTAG work. OpenOCD was able
to detect the device in the JTAG chain, but I wanted to have a native
integration with Intel tools.&lt;/p&gt;
&lt;p&gt;The efforts have now paid off, as I was able to use &lt;a href="https://www.intel.com/content/www/us/en/programmable/quartushelp/13.0/mergedProjects/program/syscon/syscon_about_emi_toolkit.htm"&gt;External Memory InterFace
Debug
Toolkit&lt;/a&gt;
to inspect the calibration results and obtain other internal data from the DDR3
memory controller.&lt;/p&gt;
&lt;h2&gt;Single bank&lt;/h2&gt;
&lt;p&gt;Presented in the following two figures are the so-called margin reports for the
read and write cycles. At the start-up, the controller performs a series of
reads and writes, and measures the data valid window. This information can be
then retrieved over the JTAG (with EMIF Debug Toolkit).&lt;/p&gt;
&lt;p&gt;&lt;img alt="Margin report for single bank read" src="www.j-marjanovic.io/images/2021_fpga_card_part_6/single_bank_read.png" style="width:30%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Margin report for single bank write" src="www.j-marjanovic.io/images/2021_fpga_card_part_6/single_bank_write.png" style="width:30%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h2&gt;Full interface&lt;/h2&gt;
&lt;p&gt;Once it was clear that the interface works correctly (and that the
reverse-engineering procedure described in my previous blog post works),
I extended the interface to the &lt;a href="https://github.com/j-marjanovic/otma-fpga-bringup/commit/59328a21fda38882297f030fe3ed7cc28ba5b509"&gt;full 72-bits and enabled the ECC&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Margin report for full interface read" src="www.j-marjanovic.io/images/2021_fpga_card_part_6/full_if_read.png" style="width:30%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Margin report for full interface write" src="www.j-marjanovic.io/images/2021_fpga_card_part_6/full_if_write.png" style="width:30%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;The margin report from the EMIF Debug Toolkit unfortunately do not convey
information on whether the results are as expected for the DDR3 interface. The
data valid window is also not presented in a misleading way, with the Unit
Interval (UI) being indicated to be 1400 ps, while in reality it is only 625 ps
(for the operation at 1600 MT/s).&lt;/p&gt;
&lt;p&gt;In a presentation of a Cyclone 10 board with a DDR3 memory controller, Intel
shows a similar result to the one achieved on the Stratix V board. From this I
would assume that the DDR3 interface is configured correctly.&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/nLEcunXRTrs" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;

&lt;h1&gt;Memory Checker IP&lt;/h1&gt;
&lt;p&gt;At this point we know that all data and control pins are working correctly, but
we have not yet really tested if the address decoding works properly.&lt;/p&gt;
&lt;p&gt;For this task I have developed a small IP core, called &lt;a href="https://github.com/j-marjanovic/chisel-stuff/tree/master/example-9-mem-checker"&gt;Memory
Checker&lt;/a&gt;.
It has an Avalon-MM master interface that can be connected to the DDR3 memory
controller. The IP can be instructed to either populate the memory with one of
the 8 patterns ("all 0s", "all 1s", "walking 1", "walking 0", "alternate",
"8-bit counter", "32-bit counter", "128-bit counter") or to read the content
back and check the content of the memory against the expected value. The results
of the checker are made available to software through the control interface.&lt;/p&gt;
&lt;p&gt;Initially I wanted to use the AXI interface on this core (to make it compatible)
with both Intel and Xilinx tools, but unfortunately I could not make the bursts
work in the Intel Platform Designer (previously known as Qsys) with the
AXI-to-Avalon adapter.&lt;/p&gt;
&lt;p&gt;Memory Checker IP in its natural habitat, connected to the DDR3 memory controller:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Memory Checker" src="www.j-marjanovic.io/images/2021_fpga_card_part_6/mem_checker_ip.png" style="width:70%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h2&gt;Driver&lt;/h2&gt;
&lt;p&gt;The IP also provides &lt;a href="https://github.com/j-marjanovic/chisel-stuff/blob/master/example-9-mem-checker/ip_cores/mem_checker/mem_checker_sw.tcl"&gt;a driver&lt;/a&gt;,
which gets automatically included in the BSP. The function &lt;code&gt;mem_check()&lt;/code&gt; performs
the memory check and outputs the information on the &lt;code&gt;stdout&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Output&lt;/h2&gt;
&lt;p&gt;The output from the memory test procedure is presented below. The main
function first confirms that it is talking to the right IP (by comparing
the expected and the real value of the ID register), then retrieves the
configuration of the IP (Avalon-MM interface width, burst length)
and then continues with the test procedure for all eight test modes.
After each test is complete, the result (PASS or FAIL) is printed, and
the throughput is presented.&lt;/p&gt;
&lt;p&gt;To test the entire 4GB of RAM, the entire procedure takes only several seconds,
which is significantly faster than the SW-based memory test, provided as
a part of Nios example design.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=================================================&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;IP&lt;/span&gt; &lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x3e3c8ec8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10003&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;Avalon&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt; &lt;span class="n"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;burst&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;all&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PASS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;67108860&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;67108860&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;write&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7816&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;read&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9662&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;all&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PASS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;67108860&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;67108860&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;write&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7816&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;read&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9662&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;walking&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PASS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;67108860&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;67108860&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;write&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7816&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;read&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9662&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;walking&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PASS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;67108860&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;67108860&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;write&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7816&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;read&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9662&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;alternate&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PASS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;67108860&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;67108860&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;write&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7816&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;read&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9662&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PASS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;67108860&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;67108860&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;write&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7816&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;read&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9662&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PASS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;67108860&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;67108860&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;write&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7816&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;read&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9662&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PASS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;67108860&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;67108860&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;write&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7816&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;read&lt;/span&gt; &lt;span class="n"&gt;throughput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9662&lt;/span&gt; &lt;span class="n"&gt;MB&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;Performance&lt;/h1&gt;
&lt;p&gt;Although the performance of the HW-accelerated memory test is several times
better than the SW-based memory test, I still wanted to see the throughput which
can be achieved and how it compares to the full bus throughput (i.e. theoretical
maximum).&lt;/p&gt;
&lt;p&gt;From my &lt;a href="https://indico.desy.de/event/23131/contributions/49392/attachments/31928/39944/ard_st3_gigevision.pdf"&gt;previous experience with Xilinx DDR4 controller&lt;/a&gt; I expected to achieve the DDR4 bus utilization of
around 80%.&lt;/p&gt;
&lt;p&gt;Show in the figure below is the read and write throughput for different burst
lengths.&lt;/p&gt;
&lt;p&gt;&lt;img alt="DDR3 throughput" src="www.j-marjanovic.io/images/2021_fpga_card_part_6/plot_ddr3_perf.png" style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;It can be noted that the read throughput reaches a reasonable level at the large
bursts. Quite surprisingly, the write level does not reach a reasonable level,
it only reaches 60% of the full bus throughput, and it is also not affected by
the burst length.&lt;/p&gt;
&lt;p&gt;To investigate this further, I have taken two captures of the Avalon interface,
once for the burst length of 4 and once for the burst length of 128.&lt;/p&gt;
&lt;p&gt;Burst length 4:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Avalon interface between Memory Checker and DDR3 controller" src="www.j-marjanovic.io/images/2021_fpga_card_part_6/burst_4_full.png" style="width:100%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;Burst length 128:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Avalon interface between Memory Checker and DDR3 controller" src="www.j-marjanovic.io/images/2021_fpga_card_part_6/burst_128.png" style="width:100%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;With these captures I can calculate what is the interface utilization, i.e. for
what percentage of cycles was &lt;code&gt;waitrequest&lt;/code&gt; signal also being asserted when the
&lt;code&gt;write&lt;/code&gt; signal was being asserted. This number is roughly 60% for both cases,
thus confirming the write throughput measurements from the Memory Checker IP.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;In this blog post I have used the knowledge obtained from reverse-engineering
the bitstream and instantiated the DDR3 controller. To verify the functionality
of the controller and the board itself (it was purchased of eBay for 40 USD
after all), I have used Intel tools (EMIF Debug Toolkit) and developed a Memory
Checker IP. The test successfully ran overnight and did not detect any errors.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;All trademarks and registered trademarks are the property of their respective owners.&lt;/p&gt;&lt;script src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;</content><category term="FPGA"></category></entry><entry><title>Stratix V accelerator card from eBay, part 5</title><link href="www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-5.html" rel="alternate"></link><published>2021-01-10T10:00:00+01:00</published><updated>2021-01-10T10:00:00+01:00</updated><author><name>Jan Marjanovic</name></author><id>tag:None,2021-01-10:www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-5.html</id><summary type="html">&lt;p&gt;The last piece of the puzzle on the Stratix V board is the DDR3 memory pinout. Once this is
figured out, I can finally start using the board for my developments. It is obvious that this is not
the most simple way to get a cheap FPGA development board, but …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The last piece of the puzzle on the Stratix V board is the DDR3 memory pinout. Once this is
figured out, I can finally start using the board for my developments. It is obvious that this is not
the most simple way to get a cheap FPGA development board, but I generally enjoy the challenges and
also took this opportunity to learn something new. Being able to use a board without proper
documentation is a valuable skill.&lt;/p&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Looking at the board from the bottom, we note that the board has 4 ICs on the bottom side and
presumably 5 ICs on the top side. The markings on the chips indicate that this is H5TC4G83BFR-PBA -
a 4 Gb (512M x 8) DDR3 IC. With a total of 9 ICs, the total interface width is 72-bit, which can be
used as a 64-bit interface with ECC.&lt;/p&gt;
&lt;p&gt;&lt;img alt="FPGA and 9 DDR3 ICs" src="www.j-marjanovic.io/images/2021_fpga_card_part_5/fpga_ddr3_ics.jpg" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;Looking at the presentation &lt;a href="https://indico.cern.ch/event/822126/contributions/3500184/attachments/1906428/3148591/Catapult_FastML_Fermilab_2019.pdf"&gt;"Heterogeneous Computing @ Microsoft" from A. Putnam and K.
Ovtcharov&lt;/a&gt;
we can see the board without the heatsink which confirms that there are 5 DDR3 ICs on the top side.
Another important detail that can be derived from this picture is the orientation of the FPGA; the
memory interface is next to the upper right corner, which would correspond to the banks 8A - 8D.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Stratix V board from the top side" src="www.j-marjanovic.io/images/2021_fpga_card_part_5/fpga_orientation.jpg" style="width:40%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;From other sources we also know that there is a 125 MHz clock being feed into the pin &lt;strong&gt;M23&lt;/strong&gt; (in the
IO bank 8D), and a dedicated high-quality clock is a must for a fast DDR3 interface.&lt;/p&gt;
&lt;h1&gt;Strategy&lt;/h1&gt;
&lt;p&gt;The DDR3 memory uses Dynamic On-Die Termination (ODT) for the data (DQ) and data strobe (DQS) pins
but uses external resistors for termination on the address and control lines. On the Stratix V
board, we can observe these resistors under the 5th DDR3 chip on the bottom side of the board.&lt;/p&gt;
&lt;p&gt;Since tracks and vias are also somehow visible, figuring out the pinout between the FPGA and
external resistors would already give us a starting point.&lt;/p&gt;
&lt;p&gt;The data, data strobe, and data mask (DM) pins do not have any external termination resistors, and
since all but 1 IC are placed in the clamshell topology, it would be also impossible to probe it
with an oscilloscope (without physically modifying the board).&lt;/p&gt;
&lt;p&gt;There are a couple of vias for DQ and DQS visible under the 5th IC which can be probed with an
oscilloscope, but this is only a small portion of the interface. A different approach is needed.&lt;/p&gt;
&lt;h2&gt;Configuration Flash (EPCS/EPCQ)&lt;/h2&gt;
&lt;p&gt;The board contains an on-board Flash which is used to configure the FPGA upon boot. We already know
that the board configures itself and exposes the PCIe endpoint, so we know that the Flash was not
erased as a part of the disposal process. It is very likely that the DDR3 controller is also a part
of the bitstream.&lt;/p&gt;
&lt;p&gt;Altera provides a method to &lt;a href="https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/an/an556.pdf"&gt;encrypt the bitstream with a 256-bit AES
algorithm&lt;/a&gt;,
with the key which is either stored in the fuses inside the device or in a volatile memory, backed
by a battery.&lt;/p&gt;
&lt;p&gt;Since the boards were never meant to be distributed to customers and were originally only used
inside the data center, and since the management of the keys and setting up the provisioning
workflow are non-trivial tasks, I would assume/hope that the bitstream stored in the Flash
memory is not encrypted.&lt;/p&gt;
&lt;p&gt;If the bitstream is not encrypted, then it should be possible to extract the pinout from the
bitstream. Since the data pins in a DDR3 memory interface can be swapped around freely (one only
needs to observe that the grouping between the data strobe and data), it is most likely enough to
classify the I/O standard of the pins in question.&lt;/p&gt;
&lt;p&gt;For &lt;code&gt;DQ&lt;/code&gt; pins we can expect bidir SSTL, for &lt;code&gt;DM&lt;/code&gt; SSTL output, for &lt;code&gt;DQS&lt;/code&gt; differential bidir SSTL, ...&lt;/p&gt;
&lt;h1&gt;HW inspection&lt;/h1&gt;
&lt;p&gt;We start our exploration by inspecting the hardware itself. One can find some &lt;a href="http://virtlab.occamlab.com/home/zapisnik/microsoft-catapult-v2"&gt;notes from VirtLab&lt;/a&gt; where a couple of pins are already mapped; this offers a good start.&lt;/p&gt;
&lt;p&gt;I prepared a small FPGA project where pins are transmitting their location as an UART message - e.g.
pin K21 will continuously transmit "K21 ". This allows quick determination of which pins are
connected to which resistors with an oscilloscope.&lt;/p&gt;
&lt;p&gt;Annotated on the picture below are the FPGA pins which can be detected on the termination resistors
and vias. I have used color-coding to indicate the voltage level; the signals annotated in cyan
have driven the output from rail to rail, which means that there is no external termination while
with the signals in red the effect of the external termination can be observed in the signal level.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Annotated termination resistors and vias" src="www.j-marjanovic.io/images/2021_fpga_card_part_5/ddr3_pinout1.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;The annotation can be then transferred to the DDR3 chip pinout - we can see that we have managed
to determine all address and control pins and a couple of data and data strobe pins. This will
be useful as a validation for our future steps.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Annotated DDR3 IC pinout" src="www.j-marjanovic.io/images/2021_fpga_card_part_5/ddr3_pinout2.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h1&gt;Reverse engineering the bitstream&lt;/h1&gt;
&lt;p&gt;At this point we have obtained every piece of information from the HW we can (without more intrusive
procedures such as desoldering the DDR3 chips away). Now it is time to have look at the bitstream
for Startix V.&lt;/p&gt;
&lt;p&gt;The collection of scripts and other resources is available on my GitHub in a repository
&lt;a href="https://github.com/j-marjanovic/otma-pin-re"&gt;otma-pin-re&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;JIC format&lt;/h2&gt;
&lt;p&gt;JIC stands for &lt;a href="https://www.intel.com/content/www/us/en/programmable/quartushelp/17.0/reference/glossary/def_jic.htm"&gt;JTAG Indirect Configuration
file&lt;/a&gt;
which contains both the data to configure the EPCS/EPSQ device itself and the actual FPGA bitstream.
Using Quartus Programmer one can dump the content from the EPCS or EPCQ into the JIC format.&lt;/p&gt;
&lt;p&gt;Wirebond on GitHub already did this and stored the result
&lt;a href="https://github.com/wirebond/catapult_v2_pikes_peak/tree/master/fpga/factory_fw"&gt;here&lt;/a&gt;. I have used
this file for my analysis.&lt;/p&gt;
&lt;h2&gt;EPCQ content&lt;/h2&gt;
&lt;p&gt;As one of the first steps I have plotted the bit density, i.e. how many bits are set in a 1024-bit
block. 1024 is an arbitrary number, chosen to make plotting simple/fast.&lt;/p&gt;
&lt;p&gt;Shown in the figure below are four different JIC files. On the first subplot we have a JIC file
which I have generated from a DDR3 example design. On the second subplot there is a JIC file from
the on-board EPCQ and on the third subplot are two JIC files (one with an offset for the FPGA
bitstream) where the compression was enabled.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Bit density of factory.jic" src="www.j-marjanovic.io/images/2021_fpga_card_part_5/jic_factory.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;We can see that the bitstream from the EPCQ (&lt;code&gt;factory.jic&lt;/code&gt;) contains two compressed FPGA images -
the first one immediately after the header and the second one at the half of the memory. Presumably,
the first image is a recovery image (since it is smaller in size) and the second one is an
application image.&lt;/p&gt;
&lt;h3&gt;Checksum&lt;/h3&gt;
&lt;p&gt;Zooming in at the beginning of the bitstream we can note an increase in bit density
every 1188 bits. This is presumably a checksum.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Checksum in the JIC file can be noted visually" src="www.j-marjanovic.io/images/2021_fpga_card_part_5/jic_checksum.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;Explored in the notebook
&lt;a href="https://github.com/j-marjanovic/otma-pin-re/blob/master/scripts/bitstream_analysis/02_crc_checksum.ipynb"&gt;bitstream_analysis/02_crc_checksum.ipynb&lt;/a&gt;
is the checksum calculation. It can be confirmed that the checksum is calculated with CRC16 with
Modbus polynomial, as it is mentioned in &lt;a href="https://www.emsec.ruhr-uni-bochum.de/media/attachments/files/2014/11/MA_Swierczynski.pdf"&gt;P. Swierczynski: Security Analysis of the Bitstream
Encryption Scheme of Altera
FPGAs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Being able to calculate a checksum on the data can serve as a confirmation
that one is correctly able to interpret the raw data. This will become
especially important once we try to decompress the bitstream.&lt;/p&gt;
&lt;h3&gt;Compression&lt;/h3&gt;
&lt;p&gt;To save the space in the Flash memory, the bitstream in the EPCQ is compressed
- this can be observed from the increased density in the plots in the previous
section.&lt;/p&gt;
&lt;p&gt;The algorithm for compression (and decompression) is described in the &lt;a href="https://patents.google.com/patent/US6525678"&gt;US patent
6525678&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To give an example, here are two excerpts, the first one from the uncompressed bitstream and the
second one from the compressed.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;227550&lt;/span&gt; &lt;span class="err"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="n"&gt;b6&lt;/span&gt; &lt;span class="n"&gt;f9&lt;/span&gt; &lt;span class="mf"&gt;81&lt;/span&gt; &lt;span class="mf"&gt;8&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;2&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;e8&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt;
&lt;span class="mf"&gt;227560&lt;/span&gt; &lt;span class="err"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="mf"&gt;2279&lt;/span&gt;&lt;span class="n"&gt;f0&lt;/span&gt; &lt;span class="err"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="n"&gt;b6&lt;/span&gt; &lt;span class="n"&gt;f9&lt;/span&gt; &lt;span class="mf"&gt;81&lt;/span&gt; &lt;span class="mf"&gt;8&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;2&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;e8&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt;
&lt;span class="mf"&gt;227&lt;/span&gt;&lt;span class="n"&gt;a00&lt;/span&gt; &lt;span class="err"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="mf"&gt;227&lt;/span&gt;&lt;span class="n"&gt;e90&lt;/span&gt; &lt;span class="err"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="n"&gt;b6&lt;/span&gt; &lt;span class="n"&gt;f9&lt;/span&gt; &lt;span class="mf"&gt;81&lt;/span&gt; &lt;span class="mf"&gt;8&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt;
&lt;span class="mf"&gt;227&lt;/span&gt;&lt;span class="n"&gt;ea0&lt;/span&gt; &lt;span class="err"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;2&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;e8&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;225900&lt;/span&gt; &lt;span class="err"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;6&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="mf"&gt;9&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt; &lt;span class="mf"&gt;81&lt;/span&gt; &lt;span class="mf"&gt;8&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;f0&lt;/span&gt; &lt;span class="mf"&gt;2&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;e8&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt;
&lt;span class="mf"&gt;225910&lt;/span&gt; &lt;span class="err"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="mf"&gt;225&lt;/span&gt;&lt;span class="n"&gt;a30&lt;/span&gt; &lt;span class="err"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;6&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="mf"&gt;9&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt; &lt;span class="mf"&gt;81&lt;/span&gt; &lt;span class="mf"&gt;8&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;f0&lt;/span&gt; &lt;span class="mf"&gt;2&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;e8&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt;
&lt;span class="mf"&gt;225&lt;/span&gt;&lt;span class="n"&gt;a40&lt;/span&gt; &lt;span class="err"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="mf"&gt;225&lt;/span&gt;&lt;span class="n"&gt;b60&lt;/span&gt; &lt;span class="err"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;6&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="mf"&gt;9&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt; &lt;span class="mf"&gt;81&lt;/span&gt; &lt;span class="mf"&gt;8&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;f0&lt;/span&gt; &lt;span class="mf"&gt;2&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;e8&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt;
&lt;span class="mf"&gt;225&lt;/span&gt;&lt;span class="n"&gt;b70&lt;/span&gt; &lt;span class="err"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We see that the non-compressed bitstream contains a sequence &lt;code&gt;b6&lt;/code&gt;, &lt;code&gt;f9&lt;/code&gt;, ... after a long string of
zeros. In the compressed bitstream the long string of zeros is interrupted by an &lt;code&gt;f&lt;/code&gt; (which
indicates that the next 4 elements should be copied from the compressed bitstream) and followed by
&lt;code&gt;b6&lt;/code&gt;, &lt;code&gt;f9&lt;/code&gt; (as in the original bitstream). The checksum is calculated after the decompression.&lt;/p&gt;
&lt;p&gt;With this out of the way, we have a full bitstream where we can start identifying individual
features.&lt;/p&gt;
&lt;h2&gt;Weak pull-up bit&lt;/h2&gt;
&lt;p&gt;One of the most simple changes regarding an IO pin is turning the weak pull-up resistor on and off.&lt;/p&gt;
&lt;p&gt;I have explored the effect of changing the value of the weak pull-up resistor in the notebook
&lt;a href="https://github.com/j-marjanovic/otma-pin-re/blob/master/scripts/extract_pin_addr/test_01-extract_pin_addr.ipynb"&gt;extract_pin_addr/test_01-extract_pin_addr.ipynb&lt;/a&gt;.
In one of the graphs, we can determine the address of the bit responsible for the weak pull-up, and
the corresponding checksum bits.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Weak Pull-Up configuration bit" src="www.j-marjanovic.io/images/2021_fpga_card_part_5/extract_pu.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;With the confirmation that a pull-up is controlled by a single bit, I have decided to use this bit
as a reference address for the rest of the configuration bits. For the classification I use bits
at addresses relative to the pull-up bit, i.e. the pull-up bit has an address 0.&lt;/p&gt;
&lt;p&gt;In the notebook
&lt;a href="https://github.com/j-marjanovic/otma-pin-re/blob/master/scripts/extract_pin_addr/01_get_pu_addr.ipynb"&gt;extract_pin_addr/01_get_pu_addr.ipynb&lt;/a&gt;
I have then determined the address of the weak pull-up bit for all pins in the banks 8A-8D. Those addresses
are then (manually) copied to
&lt;a href="https://github.com/j-marjanovic/otma-pin-re/blob/master/scripts/extract_pin_addr/knowledge.py"&gt;knowledge.py&lt;/a&gt;,
which is then used in subsequent notebooks.&lt;/p&gt;
&lt;h2&gt;Pin configuration&lt;/h2&gt;
&lt;p&gt;The next step is to determine which bits are relevant for the I/O standard on the pin. I have
prepared a lot of bitstreams with pins in different configurations, and then in the notebook
 &lt;a href="https://github.com/j-marjanovic/otma-pin-re/blob/master/scripts/extract_pin_addr/03_extract_io_std.ipynb"&gt;extract_pin_addr/03_extract_io_std.ipynb&lt;/a&gt;
extracted all the bits which are relevant for the IO standard.&lt;/p&gt;
&lt;p&gt;&lt;img alt="I/O standard configuration bits" src="www.j-marjanovic.io/images/2021_fpga_card_part_5/extract_io_std.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h2&gt;Classifier&lt;/h2&gt;
&lt;p&gt;Once I have managed to get a vector of values that are relevant for the I/O pin standard, I have
started to build a classifier. In the first attempt I let the classifier itself figure out which
bits are relevant for which features, but I had better success with a hand-crafted classifier,
presented in the notebook
&lt;a href="https://github.com/j-marjanovic/otma-pin-re/blob/master/scripts/extract_pin_addr/05_classification_manual.ipynb"&gt;extract_pin_addr/05_classification_manual.ipynb&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Validation&lt;/h2&gt;
&lt;p&gt;I have prepared a small project with an 8-bit DDR3 interface and let the classifier classify the
pins. I have purposely places also some address and control pins in the same bank, and left some
of the pins disabled. The classifier correctly classifies all the pins, the results are presented in the
notebook
&lt;a href="https://github.com/j-marjanovic/otma-pin-re/blob/master/scripts/extract_pin_addr/06_validation.ipynb"&gt;extract_pin_addr/06_validation.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Classification&lt;/h2&gt;
&lt;p&gt;At this point we can run the classifier on the decompressed image from the on-board Flash. Since
there are two images (a recovery image and an application image) available, I have decompressed both
and called them &lt;code&gt;factory_decompress0.jic&lt;/code&gt; and &lt;code&gt;factory_decompress1.jic&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I then ran the classifier on the second image and was amazed by the results. The &lt;a href="https://github.com/j-marjanovic/otma-pin-re/blob/master/scripts/extract_pin_addr/07_application.ipynb"&gt;classifier&lt;/a&gt; managed to find:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exactly all 72 &lt;code&gt;DQ&lt;/code&gt; pins&lt;/li&gt;
&lt;li&gt;17 (out of 18) &lt;code&gt;DQS&lt;/code&gt; and &lt;code&gt;DQSn&lt;/code&gt; pins,&lt;/li&gt;
&lt;li&gt;10 &lt;code&gt;DM&lt;/code&gt; pins (9 + something which is counted as a &lt;code&gt;DM&lt;/code&gt; but it is something else),&lt;/li&gt;
&lt;li&gt;25 address and control pins (out of 25), and&lt;/li&gt;
&lt;li&gt;5 unknown pins&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;At this point one could investigate why, for example, one of the DQS pins is not detected and improve
the classifier to correctly detect all pins, but I have decided to go ahead and clean-up the results
manually.&lt;/p&gt;
&lt;h2&gt;Clean-up&lt;/h2&gt;
&lt;p&gt;The clean-up was quite straightforward, since one can base the corrections on the pinout which was
determined by physically probing vias and resistors in one of the previous paragraphs.&lt;/p&gt;
&lt;p&gt;Out of 5 unknown pins, two were &lt;code&gt;CK&lt;/code&gt; and &lt;code&gt;CKn&lt;/code&gt;, one was the missing &lt;code&gt;DQSn&lt;/code&gt; pin, one was the 125 MHz
clock and one was the &lt;code&gt;RZQ&lt;/code&gt; pin. One of the pins which was incorrectly classified as &lt;code&gt;DM&lt;/code&gt; pin was
actually a reset pin (L20).&lt;/p&gt;
&lt;p&gt;The full table with the final pinout (&lt;code&gt;DQ&lt;/code&gt; pins are omitted for brevity, check the last notebook)
is presented below.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;pin&lt;/th&gt;
&lt;th align="left"&gt;dbg&lt;/th&gt;
&lt;th align="left"&gt;class&lt;/th&gt;
&lt;th align="left"&gt;addr&lt;/th&gt;
&lt;th align="left"&gt;control&lt;/th&gt;
&lt;th align="left"&gt;data&lt;/th&gt;
&lt;th align="left"&gt;misc&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;J27&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A0&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;J21&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A1&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;J29&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A2&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;L28&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A3&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;P26&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A4&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;M26&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A5&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;N25&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A6&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;P25&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A7&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;N22&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A8&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;N26&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A9&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;K27&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A10&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;L27&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A11&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;N27&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A12&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;M27&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A13&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;N21&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A14&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;K28&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;A15&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;J28&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;BA0&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;K21&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;BA1&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;L26&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;BA2&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;L24&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;CASn&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;J23&lt;/td&gt;
&lt;td align="left"&gt;inp=1, out=1, pu=0, io_std='Scls1', term=0, diff=1&lt;/td&gt;
&lt;td align="left"&gt;?&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;CK&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;J24&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=1&lt;/td&gt;
&lt;td align="left"&gt;?&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;CKn&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;K24&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;CKE&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;N23&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;CSn&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;M21&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;ODT&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;L21&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;RASn&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;L20&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DM&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;reset&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;P23&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='Scls1', term=0, diff=0&lt;/td&gt;
&lt;td align="left"&gt;addr&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;WEn&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;N33&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DM&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;DM0&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;T31&lt;/td&gt;
&lt;td align="left"&gt;inp=1, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DQ&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;DQ0&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;P34&lt;/td&gt;
&lt;td align="left"&gt;inp=1, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DQ&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;DQ1&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;N34&lt;/td&gt;
&lt;td align="left"&gt;inp=1, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DQ&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;DQ4&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;M33&lt;/td&gt;
&lt;td align="left"&gt;inp=1, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DQ&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;DQ5&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;L34&lt;/td&gt;
&lt;td align="left"&gt;inp=1, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DQ&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;DQ7&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;N32&lt;/td&gt;
&lt;td align="left"&gt;inp=1, out=1, pu=0, io_std='S', term=1, diff=1&lt;/td&gt;
&lt;td align="left"&gt;DQS&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;DQS0&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;M32&lt;/td&gt;
&lt;td align="left"&gt;inp=1, out=1, pu=0, io_std='S', term=1, diff=1&lt;/td&gt;
&lt;td align="left"&gt;DQS&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;DQS0n&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;M23&lt;/td&gt;
&lt;td align="left"&gt;inp=1, out=0, pu=0, io_std='2V5', term=None, diff=0&lt;/td&gt;
&lt;td align="left"&gt;?&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;125 MHz clk&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;E23&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='S', term=1, diff=1&lt;/td&gt;
&lt;td align="left"&gt;?&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;DQS2n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;B34&lt;/td&gt;
&lt;td align="left"&gt;inp=1, out=0, pu=0, io_std='2V5', term=None, diff=0&lt;/td&gt;
&lt;td align="left"&gt;?&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;RZQ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;D21&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DM&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;D22&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DM&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;D25&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DM&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;E27&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DM&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;D28&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DM&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;E30&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DM&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;C34&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DM&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;H34&lt;/td&gt;
&lt;td align="left"&gt;inp=0, out=1, pu=0, io_std='S', term=1, diff=0&lt;/td&gt;
&lt;td align="left"&gt;DM&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;In this blog post I have presented the procedure to obtain the DDR3 pinout from the Stratix V board.
I have not yet tested the pinout on the real hardware, but I am pretty confident that it should work
- I will leave this for the next post.&lt;/p&gt;
&lt;p&gt;In general, the procedure was relatively straightforward, but had some obstacles on the way,
for example compression, the not-completely-regular structure of the bitstream, and the checksums.
I was also quite lucky that the bitstream itself was not encrypted, although it is understandable
why this was not the case.&lt;/p&gt;
&lt;p&gt;In the next blog post I plan to verify that the pinout presented here is accurate and perform
some memory tests.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;All trademarks and registered trademarks are the property of their respective owners.&lt;/p&gt;&lt;script src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;</content><category term="FPGA"></category></entry><entry><title>Stratix V accelerator card from eBay, part 4</title><link href="www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-4.html" rel="alternate"></link><published>2020-10-11T16:00:00+02:00</published><updated>2020-10-11T16:00:00+02:00</updated><author><name>Jan Marjanovic</name></author><id>tag:None,2020-10-11:www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-4.html</id><summary type="html">&lt;p&gt;In the part 4 of the Odyssey with the Startix V board from the eBay, I explore
the QSFP+ port and establish a 40 Gigabit Ethernet connection to a computer
with an Intel X710 40GbE network adapter.&lt;/p&gt;
&lt;h1&gt;HW overview&lt;/h1&gt;
&lt;p&gt;Since this board was designed to run in a datacenter, the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In the part 4 of the Odyssey with the Startix V board from the eBay, I explore
the QSFP+ port and establish a 40 Gigabit Ethernet connection to a computer
with an Intel X710 40GbE network adapter.&lt;/p&gt;
&lt;h1&gt;HW overview&lt;/h1&gt;
&lt;p&gt;Since this board was designed to run in a datacenter, the connectivity is of
major importance. The board can connect to the host CPU over PCIe x16
connection, and can communicate with other boards and external world over 2
QSFP+ connectors.&lt;/p&gt;
&lt;p&gt;The transceivers in the &lt;a href="https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/hb/stratix-v/stx5_51001.pdf"&gt;Stratix V
GS&lt;/a&gt;
can operate at 14.1 Gbps, which means that the board can run 40 Gigabit Ethernet
(4x10.3125 Gbps), InfiniBand FDR (56 Gbps = 4x14.0 Gbps) and other fast
protocols.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Stratix V board with QSFP cable" src="www.j-marjanovic.io/images/2020_fpga_card_part_4/qsfp_cable.jpg" style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h1&gt;QSFP+ management interface&lt;/h1&gt;
&lt;p&gt;As described in &lt;a href="https://members.snia.org/document/dl/25896"&gt;SFF-8436: Specification for QSFP+ 4X 10 Gb/s Pluggable
Transceiver&lt;/a&gt;, the QSFP module
contains a relatively simple management interface, accessible over an I2C bus.&lt;/p&gt;
&lt;p&gt;First I &lt;a href="https://github.com/j-marjanovic/otma-fpga-bringup/blob/master/software/otma_bringup/src/mini_i2cdetect.c"&gt;implemented a mini equivalent to &lt;code&gt;i2cdetect&lt;/code&gt;&lt;/a&gt; to check if I am probing a
correct I2C bus. As expected, an I2C device with address 0x50 replies to our
request:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt; 0000 |          &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt;&lt;/span&gt;
&lt;span class="c"&gt; 0010 | &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt;&lt;/span&gt;
&lt;span class="c"&gt; 0020 | &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt;&lt;/span&gt;
&lt;span class="c"&gt; 0030 | &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt;&lt;/span&gt;
&lt;span class="c"&gt; 0040 | &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt;&lt;/span&gt;
&lt;span class="c"&gt; 0050 | 50 &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt;&lt;/span&gt;
&lt;span class="c"&gt; 0060 | &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt;&lt;/span&gt;
&lt;span class="c"&gt; 0070 | &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt; &lt;/span&gt;&lt;span class="nb"&gt;--&lt;/span&gt;&lt;span class="c"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We can then continue by dumping the content of the module EEPROM:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;rc = 0 | 0d 02 06 00 00 00 00 00 00 00 00 00 00 00 00 00
rc = 0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
rc = 0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
rc = 0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
rc = 0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
rc = 0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
rc = 0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
rc = 0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
rc = 0 | 0d 00 23 08 00 00 00 00 00 00 00 05 8d 00 00 00
rc = 0 | 00 00 02 a0 4d 65 6c 6c 61 6e 6f 78 20 20 20 20
rc = 0 | 20 20 20 20 0f 00 02 c9 36 37 30 37 35 39 2d 42
rc = 0 | 32 33 20 20 20 20 20 20 41 31 04 06 09 00 46 27
rc = 0 | 00 00 00 00 36 43 32 32 31 32 30 37 36 58 20 20
rc = 0 | 20 20 20 20 31 32 30 33 32 37 20 20 00 00 00 64
rc = 0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
rc = 0 | 00 00 00 00 00 00 00 00 00 00 02 00 00 30 00 00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The cable is correctly identified as Mellanox 670759-B23 cable.&lt;/p&gt;
&lt;h1&gt;40G Ethernet MAC&lt;/h1&gt;
&lt;p&gt;To implement the physical layer of the Ethernet protocol I used &lt;a href="https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug_40_100gbe.pdf"&gt;40- and
100-Gbps Ethernet MAC and PHY
MegaCore&lt;/a&gt;.
Without an appropriate license this IP can be evaluated for an hour, which is
not a lot, but enough to test the hardware capabilities of the FPGA board.&lt;/p&gt;
&lt;p&gt;To clock the transceiver part I have used the 644.53125 MHz on-board oscillator
which I have explored in detail in &lt;a href="https://j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-3.html"&gt;my previous
post&lt;/a&gt;.
The application part is clocked at 312.5 MHz, generated from the same 644 MHz
oscillator.&lt;/p&gt;
&lt;p&gt;In the Qsys I have added a &lt;a href="http://www.altera.com/literature/ug/xcvr_user_guide.pdf"&gt;Transceiver Reconfiguration
Controller&lt;/a&gt; and
connected it to a &lt;em&gt;JTAG to Avalon Master Bridge&lt;/em&gt;, so that I can perform Eye Scan
measurements and change other transceiver configurations.&lt;/p&gt;
&lt;p&gt;With everything in place, I have programmed the bitstream to the FPGA, and the
&lt;code&gt;dmesg&lt;/code&gt; output in Linux on the other side of the link reported some good news,
the link is up:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[  615.469842] i40e 0000:01:00.0 enp1s0: NIC Link is Up, 40 Gbps Full Duplex, Flow Control: None
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;Eye scan&lt;/h1&gt;
&lt;p&gt;Once the link is established, we can use &lt;a href="https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/an/an605.pdf"&gt;Transceiver Toolkit
EyeQ&lt;/a&gt;
to verify the link quality on the receiver. EyeQ circuitry uses an additional
data sampler to sample the receiving data at a time and voltage offset, and
compares those to the one received from the center of the data eye. With
this method, it can determine BER (Bit Error Rate) for each point in the 2D
eye diagram.&lt;/p&gt;
&lt;p&gt;Shown in figures below are the results from eye scan on all 4 lanes.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Eye scan on channel 0" src="www.j-marjanovic.io/images/2020_fpga_card_part_4/eye_rx0.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Eye scan on channel 1" src="www.j-marjanovic.io/images/2020_fpga_card_part_4/eye_rx1.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Eye scan on channel 2" src="www.j-marjanovic.io/images/2020_fpga_card_part_4/eye_rx2.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Eye scan on channel 3" src="www.j-marjanovic.io/images/2020_fpga_card_part_4/eye_rx3.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;We can see that the eyes are not open very wide, but on the other hand this is
an expected result with a relatively high data rate and a passive coper cable.
Anyway, the eyes seems to be open wide enough to provide reliable transmission
of the data.&lt;/p&gt;
&lt;h1&gt;Logic Analyzer&lt;/h1&gt;
&lt;p&gt;At this point we can use &lt;em&gt;SystemTap II Logic Analyzer&lt;/em&gt; to capture the received
packets from the 40G Ethernet MAC interface.&lt;/p&gt;
&lt;p&gt;Shown in figure below is the capture with the SignalTap, with the data from an
ARP packet, send from the PC when we want to ping an address.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ARP request captured with SignalTap" src="www.j-marjanovic.io/images/2020_fpga_card_part_4/arp.png" style="width:100%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;An experienced reader will recognize a broadcast MAC address (&lt;code&gt;0xFFFFFFFFFF&lt;/code&gt;),
ARP Ether Type (&lt;code&gt;0x0806&lt;/code&gt;), and some other elements in the ARP packet.&lt;/p&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;In this short blog post I have explored the 40 Gigabit Ethernet on the Stratix V
board. I have managed to establish a link to a computer, and verify the signal
integrity of the received signals.&lt;/p&gt;
&lt;p&gt;For the next post I will prepare a minimal UDP/IPv4 core, and transfer some
UDP packets between the computer and the FPGA.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;All trademarks and registered trademarks are the property of their respective
owners.&lt;/p&gt;&lt;script src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;</content><category term="FPGA"></category></entry><entry><title>Stratix V accelerator card from eBay, part 3</title><link href="www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-3.html" rel="alternate"></link><published>2020-09-06T16:00:00+02:00</published><updated>2020-09-06T16:00:00+02:00</updated><author><name>Jan Marjanovic</name></author><id>tag:None,2020-09-06:www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-3.html</id><summary type="html">&lt;p&gt;As mentioned in my &lt;a href="https://j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-2.html"&gt;previous blog post&lt;/a&gt;, the next step would be
to get the JTAG running in Quaruts. In this blog post I describe how I managed
to develop a library as an interface between the FPGA board and Quartus, and
demonstrate the developed interface to download the bitstream …&lt;/p&gt;</summary><content type="html">&lt;p&gt;As mentioned in my &lt;a href="https://j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-2.html"&gt;previous blog post&lt;/a&gt;, the next step would be
to get the JTAG running in Quaruts. In this blog post I describe how I managed
to develop a library as an interface between the FPGA board and Quartus, and
demonstrate the developed interface to download the bitstream and to debug
the Nios II soft-core processor.&lt;/p&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;h2&gt;HW overview&lt;/h2&gt;
&lt;p&gt;The Stratix V board contains a 4-pin USB port (with a non-standard connector),
to which an &lt;a href="https://www.ftdichip.com/Products/ICs/FT232H.htm"&gt;FT232H&lt;/a&gt; is
attached, containing &lt;em&gt;Multi-Protocol Synchronous Serial Engine (MPSSE)&lt;/em&gt; which
can be used to implement the JTAG protocol.&lt;/p&gt;
&lt;p&gt;I am a little bit surprised that the board includes the full JTAG programmer and
not only the 10-pin JTAG header, which can be then used by the developers on
their development setups. On the other hand, the cost of an FT232H is 2.70 EUR
on Mouser for a reel, which is negligible compared to the cost of the board. I
can also understand that having a JTAG debugger available on each board is
valuable when monitoring the operating conditions (e.g. transceiver link quality
with the
&lt;a href="https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/an/an605.pdf"&gt;EyeQ&lt;/a&gt;)
and to debug and investigate the synchronization issues between the servers in
the deployment.&lt;/p&gt;
&lt;p&gt;I was not able to find more information about this particular USB/JTAG
connection on the Open Compute Project website.&lt;/p&gt;
&lt;h2&gt;Quartus software suite&lt;/h2&gt;
&lt;p&gt;Intel® Quartus® provides several programs that are extremely useful for
development for Intel/Altera FPGAs.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Quartus Programmer&lt;/strong&gt; which, as the name suggests, allows
  programming/configuring the FPGA devices over the JTAG chain, and it can also
  program the non-volatile memories attached to the FPGAs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;System Console&lt;/strong&gt; provides "visibility into your system" - one can use JTAG
  to Avalon MM bridge to read and write the registers in the IPs, and
  &lt;em&gt;Transceiver Toolkit&lt;/em&gt; and &lt;em&gt;External Memory Interface Toolkits&lt;/em&gt; both greatly
  simplify the bringup and debug of transceivers and external memories&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SignalTap&lt;/strong&gt; is an embedded logic analyzer, useful for debugging the logic
  in hardware, with the input from real devices&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nios II Debugger&lt;/strong&gt; provides access to soft-core Nios II processor, and
  it can be used to download the programs, to debug them through GDB, and to
  obtain the output from the program over the &lt;em&gt;JTAG UART&lt;/em&gt; IP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To my knowledge OpenOCD does not provide all these features and Quartus also
does not seem to be able to interface to OpenOCD.&lt;/p&gt;
&lt;h2&gt;OpenOCD&lt;/h2&gt;
&lt;p&gt;Nonetheless, OpenOCD can be used to scan the JTAG chain, and confirm
that the FTDI really is connected to the JTAG port of the FPGA:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ openocd -f interface/ftdi/um232h.cfg -c &lt;span class="s2"&gt;&amp;quot;adapter_khz 100; transport select jtag; jtag newtap auto0 tap -irlen 10 -expected-id 0x029070dd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
Open On-Chip Debugger &lt;span class="m"&gt;0&lt;/span&gt;.10.0
Licensed under GNU GPL v2
For bug reports, &lt;span class="nb"&gt;read&lt;/span&gt;
    http://openocd.org/doc/doxygen/bugs.html
adapter speed: &lt;span class="m"&gt;100&lt;/span&gt; kHz
Info : clock speed &lt;span class="m"&gt;100&lt;/span&gt; kHz
Info : JTAG tap: auto0.tap tap/device found: 0x029070dd &lt;span class="o"&gt;(&lt;/span&gt;mfg: 0x06e &lt;span class="o"&gt;(&lt;/span&gt;Altera&lt;span class="o"&gt;)&lt;/span&gt;, part: 0x2907, ver: 0x0&lt;span class="o"&gt;)&lt;/span&gt;
Warn : gdb services need one or more targets defined
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This gives hope that at least on the HW side, integrating the board with Quartus
will be easy.&lt;/p&gt;
&lt;h1&gt;JTAG library&lt;/h1&gt;
&lt;p&gt;Some information on how to add a custom cable can be found on &lt;a href="https://forums.intel.com/s/question/0D50P00003yyL2bSAE/bemicro-and-programming-under-linux"&gt;Intel
forums&lt;/a&gt;.
At the startup, Quartus scans the &lt;code&gt;linux64&lt;/code&gt; folder (if running on 64-bit Linux)
and searches for the shared object files which start with the &lt;code&gt;libjtag_hw.&lt;/code&gt; The
shared object is then loaded, and a function called &lt;code&gt;get_supported_hardware&lt;/code&gt; is
called. This function returns a structure, containing function pointers for
various operations that the programmer and other utilities can perform.&lt;/p&gt;
&lt;p&gt;To understand this (undocumented) interface a little bit better, I first
implemented &lt;a href="https://github.com/j-marjanovic/jtag-quartus-ft232h/blob/master/src/jtag_hw_dummy.cpp"&gt;a library with a dummy JTAG TAP
controller&lt;/a&gt;.
This library can be copied or linked in the &lt;code&gt;linux64&lt;/code&gt; folder, and then used in
Quartus Programmer. The implementation of the JTAG pretends that it is a Stratix
V device (by having the same &lt;code&gt;IDCODE&lt;/code&gt;) and then discards all the bits which are
downloaded to the device. If somebody has too much time, one can easily extend
this to create a very complicated &lt;code&gt;.sof&lt;/code&gt; to &lt;code&gt;.rbf&lt;/code&gt; converter. Finally, the
dummy device fakes the status register to communicate that the &lt;code&gt;CONF_DONE&lt;/code&gt; is
high at the end of the programming. For debugging purposes, the library prints
extensive debug information over a UNIX socket.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A dummy JTAG device being programmed in Quartus Programmer" src="www.j-marjanovic.io/images/2020_fpga_card_part_3/jtag_dummy.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;Once this part in place, it is easy to imagine that combining the library
of the dummy JTAG and the HW-related part of the OpenOCD is not so complicated.
Since the OpenOCD is licensed under GPL v2, I have decided to re-use the code
for MPSSE and FT232H and to also license my library under the same license.&lt;/p&gt;
&lt;h2&gt;Downloading the bitstream&lt;/h2&gt;
&lt;p&gt;Here is the documentation of the first victory in this convoluted JTAG bring-up
process, the bitstream is successfully downloaded into the FPGA, and an LED on
the board is blinking, indicating a total success.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Stratix V being programmed over the on-board FT232H" src="www.j-marjanovic.io/images/2020_fpga_card_part_3/jtag_ft232h.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h2&gt;JTAG to Avalon&lt;/h2&gt;
&lt;p&gt;To check if all functions of the JTAG cable are working, I have prepared a small
IP (discussed below) and connected it to &lt;a href="https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug_embedded_ip.pdf"&gt;JTAG to Avalon Master
Bridge&lt;/a&gt;.
This IP provides access to the Avalon interconnect over &lt;strong&gt;System Console&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Shown here is a read of 12 words from a certain address in the Avalon MM memory
space:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="k"&gt;set&lt;/span&gt; jtag_master &lt;span class="k"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;lindex&lt;/span&gt; &lt;span class="k"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;get_service_paths&lt;/span&gt; master&lt;span class="k"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="k"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;devices&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;SGSMD5H&lt;span class="k"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;SGSMD5K1&lt;span class="o"&gt;|&lt;/span&gt;..&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;bus-instance&lt;span class="err"&gt;#&lt;/span&gt;OTMA FT232H&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;link&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;JTAG&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;110&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;132&lt;/span&gt; v1 &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;phy_0&lt;span class="o"&gt;/&lt;/span&gt;master
&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;open_service&lt;/span&gt; master &lt;span class="nv"&gt;$jtag_master&lt;/span&gt;

&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;master_read_32&lt;/span&gt; &lt;span class="nv"&gt;$jtag_master&lt;/span&gt; &lt;span class="mh"&gt;0x1000&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="nv"&gt;0xc10cc272&lt;/span&gt; &lt;span class="mh"&gt;0x00010000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x266ac4b1&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;master_read_32&lt;/span&gt; &lt;span class="nv"&gt;$jtag_master&lt;/span&gt; &lt;span class="mh"&gt;0x1000&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="nv"&gt;0xc10cc272&lt;/span&gt; &lt;span class="mh"&gt;0x00010000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x266ac4ac&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;master_read_32&lt;/span&gt; &lt;span class="nv"&gt;$jtag_master&lt;/span&gt; &lt;span class="mh"&gt;0x1000&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="nv"&gt;0xc10cc272&lt;/span&gt; &lt;span class="mh"&gt;0x00010000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x266ac4a8&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;master_read_32&lt;/span&gt; &lt;span class="nv"&gt;$jtag_master&lt;/span&gt; &lt;span class="mh"&gt;0x1000&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="nv"&gt;0xc10cc272&lt;/span&gt; &lt;span class="mh"&gt;0x00010000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x266ac4a3&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="mh"&gt;0x00000000&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I will explain later what exactly are we seeing here, for now let's just accept
that &lt;em&gt;JTAG to Avalon bridge&lt;/em&gt; works, and it reads a magic number register
(&lt;code&gt;0xc10cc272&lt;/code&gt;), a version register (&lt;code&gt;0x00010000&lt;/code&gt;), and the &lt;code&gt;meas_clk[5]&lt;/code&gt; register
reports a value between 644531368 Hz and 644531377 Hz.&lt;/p&gt;
&lt;h2&gt;Nios II&lt;/h2&gt;
&lt;p&gt;For a final test, I wanted to see if I can download a program into the Nios II
instruction memory, run the program and observe the output over the JTAG UART
interface.&lt;/p&gt;
&lt;p&gt;Also here there were no obstacles with the home-made JTAG driver, and
I could successfully perform all tasks necessary to download and debug the
Nios II core, as also presented on the screenshot below.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A program being debugged over Nios II debugger over the on-board FT232H" src="www.j-marjanovic.io/images/2020_fpga_card_part_3/nios_debugger.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h1&gt;Clock&lt;/h1&gt;
&lt;p&gt;The board contains an &lt;a href="https://www.idt.com/us/en/document/dst/idt8n4q001-datasheet"&gt;IDT8N4Q001 programmable clock
oscillator&lt;/a&gt;, which
is most likely used to generate the clocks needed for 40 Gigabit Ethernet (e.g.
156.25 MHz) and maybe for other communication protocols on the QSFP slots. Since
none of the currently available resources
(&lt;a href="https://github.com/wirebond/catapult_v2_pikes_peak"&gt;wirebond/catapult_v2_pikes_peak&lt;/a&gt;
and &lt;a href="http://virtlab.occamlab.com/home/zapisnik/microsoft-catapult-v2"&gt;Microsoft's Catapult v2 (Pikes
Peak)&lt;/a&gt;)
mentions where the IDT is connected to FPGA, I had to find out this myself.&lt;/p&gt;
&lt;p&gt;The oscillator on my board has a code &lt;code&gt;2059&lt;/code&gt;, which according to &lt;a href="https://www.idt.com/us/en/document/mau/femtoclock-ng-ceramic-package-xo-and-vcxo-ordering-information"&gt;the document
from
IDT&lt;/a&gt;
produces 644.53125 MHz for all values of &lt;code&gt;FSEL&lt;/code&gt; in the default configuration.
This matches the previously measured frequency at the input &lt;code&gt;CLK_R_REFCLK5&lt;/code&gt;
(pins &lt;code&gt;T7&lt;/code&gt; and &lt;code&gt;T6&lt;/code&gt;).&lt;/p&gt;
&lt;h2&gt;Clock counter&lt;/h2&gt;
&lt;p&gt;I have written a small IP to measure the frequency of several clocks from a
known clock frequency. As a known frequency I have used the 125 MHz on-board
oscillator.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Clock-counter IP block diagram" src="www.j-marjanovic.io/images/2020_fpga_card_part_3/clock_counter.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;The clock-counter IP generates a strobe signal with a frequency of 0.5 Hz (i.e.
pulse width of 1 s). Each of the measured clocks counts with an independent
counter. When a transition of the strobe signal is detected, the counter value
is stored in a register (accessible on Avalon MM interface) and the counter
value is reset to 0. The counter then continuos counting, until the next
transition is detected and the same procedure is repeated.&lt;/p&gt;
&lt;p&gt;Since the counter is active for exactly a second (within a certain ppm range)
before it gets stored in a register, the value stored in the register is the
frequency of the measured clock, in Hertz.&lt;/p&gt;
&lt;p&gt;The clock-domain crossing for the registers is non-existent, the registers
are loaded from one clock (from the measured clock) and read from the Avalon
interface clocks. Since the register is updated only once per second (and
thus the possibility that we read during an update is quite low) and since
this is only used for diagnostics, not implementing a proper CDC can
be tolerated.&lt;/p&gt;
&lt;h2&gt;IDT driver&lt;/h2&gt;
&lt;p&gt;I prepared &lt;a href="https://github.com/j-marjanovic/otma-fpga-bringup/blob/25f084c1b9c3982f7a8b281c95cab5e36f978822/software/otma_bringup/src/IDT8NxQ001.c"&gt;a driver for the IDT
oscillator&lt;/a&gt;,
which provides:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a function to decode the bytes into a proper structure (can be used to inspect
  the current configuration),&lt;/li&gt;
&lt;li&gt;a function to encode the structure in bytes (can be used to generate the bytes
  to be written into the device),&lt;/li&gt;
&lt;li&gt;a function to configure all relevant fields (per channel) to obtain the
  desired frequency&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and some other functions.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/j-marjanovic/otma-fpga-bringup/blob/25f084c1b9c3982f7a8b281c95cab5e36f978822/software/otma_bringup/src/main.c"&gt;main
program&lt;/a&gt;
configures 4 different frequencies, selects one of the four, and then goes into a
loop where it prints the measured frequency once per second.&lt;/p&gt;
&lt;p&gt;Here is the output of the program:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="nl"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ident&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Oxcl0cc272&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x00010000&lt;/span&gt;
&lt;span class="n"&gt;IDT8NXQOO1&lt;/span&gt; &lt;span class="nl"&gt;config&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nl"&gt;MINT&lt;/span&gt;     &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;
  &lt;span class="nl"&gt;MFRAC&lt;/span&gt;    &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;000000&lt;/span&gt; &lt;span class="mo"&gt;000000&lt;/span&gt; &lt;span class="mo"&gt;000000&lt;/span&gt; &lt;span class="mo"&gt;00000&lt;/span&gt;
  &lt;span class="nl"&gt;N&lt;/span&gt;        &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;
  &lt;span class="nl"&gt;P&lt;/span&gt;        &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mo"&gt;00&lt;/span&gt;
  &lt;span class="nl"&gt;DSM_ENA&lt;/span&gt;  &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
  &lt;span class="nl"&gt;LF&lt;/span&gt;       &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="nl"&gt;CP&lt;/span&gt;       &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
  &lt;span class="nl"&gt;FSEL&lt;/span&gt;     &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="nl"&gt;nPLL_BYP&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="nl"&gt;ADC_ENA&lt;/span&gt;  &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;Finished&lt;/span&gt; &lt;span class="n"&gt;configuring&lt;/span&gt; &lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;oscillator&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;entering&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6250002&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;103430663&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250082&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250082&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250085&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250086&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250086&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250085&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250086&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250084&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250083&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250082&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250082&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250082&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250081&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;frequency&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDT&lt;/span&gt; &lt;span class="n"&gt;osc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;156250084&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="p"&gt;[...]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We see that after the measurement has stabilized, we are receiving the clock
which we have configured, and we see that both the reference clock (125 MHz to
generate the strobe signal) and the measured clock have a low wander and a low
offset.&lt;/p&gt;
&lt;h1&gt;Conclusion and future plans&lt;/h1&gt;
&lt;p&gt;I have managed to prepare a setup that will allow me to develop and debug the
Stratix V FPGA directly from Quartus. I am satisfied that I could develop a
software solution and use the on-board FTDI chip, and I did not have to solder
wires for the JTAG to the board.&lt;/p&gt;
&lt;p&gt;With the access to useful tools in Quartus (e.g. SignalTap, Console, Nios II
debugger, Transceiver toolkit, ...) I believe bringing up the rest of the board
will be much easier.&lt;/p&gt;
&lt;p&gt;Finally, to validate that the library for the JTAG cable runs reliably, I have
used it to develop a small program that can configure the on-board oscillator
to a desired frequency, in my case 156.25 MHz. I plan to use this for a test
of the transceivers connected to the QSFP slots.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;All trademarks and registered trademarks are the property of their respective
owners.&lt;/p&gt;&lt;script src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;</content><category term="FPGA"></category></entry><entry><title>Stratix V accelerator card from eBay, part 2</title><link href="www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-2.html" rel="alternate"></link><published>2020-06-07T16:00:00+02:00</published><updated>2020-06-07T16:00:00+02:00</updated><author><name>Jan Marjanovic</name></author><id>tag:None,2020-06-07:www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay-part-2.html</id><summary type="html">&lt;p&gt;In my previous blog post I have explored the FPGA card I have purchased on eBay,
and in this post I will present an adapter card which I have developed. The
adapter provides PCI Express connection between a normal card-edge slot and the
FPGA card, as well as the access …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In my previous blog post I have explored the FPGA card I have purchased on eBay,
and in this post I will present an adapter card which I have developed. The
adapter provides PCI Express connection between a normal card-edge slot and the
FPGA card, as well as the access to the I2C bus and some additional signals.&lt;/p&gt;
&lt;p&gt;To summarize my previous blog post, the FPGA card has a 160-pin Samtec
connector, providing power (12V), I2C bus for management, and a total of 16
lanes for PCI Express.&lt;/p&gt;
&lt;h1&gt;The adapter&lt;/h1&gt;
&lt;p&gt;To keep the cost down, I have tried to make the adapter as small as possible,
and at this point to only develop a proof-of-concept. On this first variant
of the adapter only connects one PCIe lane, and I plan a second variant where
all 8 or 16 lanes will be connected to the PCIe edge connector.&lt;/p&gt;
&lt;p&gt;The KiCad project for the adapter card is available on &lt;a href="https://github.com/j-marjanovic/ocs-tray-mezzanine-adapter"&gt;my
GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Shown in the image below are the relevant parts of the adapter card.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Block diagram of the adapter card" src="www.j-marjanovic.io/images/2020_fpga_card_part_2/otma.png" style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;To connect to the PCIe slot I have purchased one of those &lt;a href="https://lmgtfy.com/?q=bitcoin+pci+express+riser+card&amp;amp;t=i"&gt;Bitcoin mining riser
cards&lt;/a&gt;, which provide
connections between PCIe slot and a USB3 cable. Since there are a total of
4 PCIe reference clock inputs per OCS specification, I have distributed
the clock to all inputs using a dedicated IC. I have connected the management
I2C bus (&lt;code&gt;MEZZ_SDA&lt;/code&gt; and &lt;code&gt;MEZZ_SCL&lt;/code&gt;) to a header, which allows me to explore the
bus with a Raspberry Pi for example, as shown in the picture below.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Raspberry Pi connected to the management I2C bus" src="www.j-marjanovic.io/images/2020_fpga_card_part_2/adapter_rpi.jpg" style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;h1&gt;I2C&lt;/h1&gt;
&lt;p&gt;Having a Raspberry Pi connected to the I2C bus, we can first explore the
present devices.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;i2cdetect&lt;/code&gt; we can find all devices which have acknowledged their I2C
address:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pi@raspberrypi:~ $ i2cdetect -y 1
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
40: -- -- -- -- -- -- -- -- -- -- -- -- 4c -- -- -- 
50: -- 51 -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
70: -- -- -- -- -- -- -- 77         
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We see the EEPROM at the address 0x51, and another two devices at addresses 0x4C
and 0x77 - I would assume that these are some kind of sensors and/or regulators.&lt;/p&gt;
&lt;h2&gt;IPMI FRU&lt;/h2&gt;
&lt;p&gt;We can now use the &lt;code&gt;i2cdump&lt;/code&gt; to dump the content of the EEPROM. As I have
expected, the EEPROM is used by the Baseboard Management Controller (or
something similar) and the content is compliant with &lt;a href="https://www.intel.com/content/dam/www/public/us/en/documents/product-briefs/platform-management-fru-document-rev-1-2-feb-2013.pdf"&gt;IPMI Platform Management
FRU Information Storage
Definition&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The following information are stored in the EEPROM:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ChassisArea:
  version: 1
  length: 32 bytes
  chassis type: Rack Mount Chassis
  part nr: X907370-001
  serial nr: (len 0)
  checksum: 146 (OK)
BoardArea:
  version: 1
  length: 64 bytes
  lang: 25
  mfg date: 2016-01-06 03:26
  mfgr: Microsoft
  prod_name: PPFPGA
  serial: OLJ60100194
  part: X900563-001
  file id: FRU 1.0
  checksum: 108 (OK)
ProductArea:
  version: 1
  length: 72 bytes
  mfgr: Microsoft
  prod_name: PPFPGA
  part_nr: X900563-001
  part_ver: 1.0
  part_sn: OLJ60100194
  asset_tag:
  file id: 1.0
  checksum: 241 (OK) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;From my understanding of the IPMI standard, the Chassis information should
not be present on this card:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A system can have multiple FRU Information Devices within a chassis, but only
one device should provide the Chassis Info Area. Thus, this area will
typically be absent from most FRU Information Devices.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;PCI Express&lt;/h1&gt;
&lt;p&gt;And finally, the most interesting and the most challenging part, the PCI Express
connection.&lt;/p&gt;
&lt;p&gt;I have plugged in the card, as shown on the image below and turned on the computer. &lt;/p&gt;
&lt;p&gt;&lt;img alt="PCIe connection over USB cable" src="www.j-marjanovic.io/images/2020_fpga_card_part_2/adapter_pcie.jpg" style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;p&gt;And it works! Using &lt;code&gt;lspci&lt;/code&gt; command to list all the devices visible to the CPU,
one can also note the Microsoft card:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ lspci
00:00.0 Host bridge: Intel Corporation 2nd Generation Core Processor Family DRAM Controller (rev 09)
00:01.0 PCI bridge: Intel Corporation Xeon E3-1200/2nd Generation Core Processor Family PCI Express Root Port (rev 09)
00:02.0 VGA compatible controller: Intel Corporation 2nd Generation Core Processor Family Integrated Graphics Controller (rev 09)
00:16.0 Communication controller: Intel Corporation 6 Series/C200 Series Chipset Family MEI Controller #1 (rev 04)
00:16.2 IDE interface: Intel Corporation 6 Series/C200 Series Chipset Family IDE-r Controller (rev 04)
00:16.3 Serial controller: Intel Corporation 6 Series/C200 Series Chipset Family KT Controller (rev 04)
00:19.0 Ethernet controller: Intel Corporation 82579LM Gigabit Network Connection (Lewisville) (rev 04)
00:1a.0 USB controller: Intel Corporation 6 Series/C200 Series Chipset Family USB Enhanced Host Controller #2 (rev 04)
00:1b.0 Audio device: Intel Corporation 6 Series/C200 Series Chipset Family High Definition Audio Controller (rev 04)
00:1c.0 PCI bridge: Intel Corporation 6 Series/C200 Series Chipset Family PCI Express Root Port 1 (rev b4)
00:1c.4 PCI bridge: Intel Corporation 6 Series/C200 Series Chipset Family PCI Express Root Port 5 (rev b4)
00:1c.6 PCI bridge: Intel Corporation 6 Series/C200 Series Chipset Family PCI Express Root Port 7 (rev b4)
00:1d.0 USB controller: Intel Corporation 6 Series/C200 Series Chipset Family USB Enhanced Host Controller #1 (rev 04)
00:1e.0 PCI bridge: Intel Corporation 82801 PCI Bridge (rev a4)
00:1f.0 ISA bridge: Intel Corporation Q67 Express Chipset LPC Controller (rev 04)
00:1f.2 SATA controller: Intel Corporation 6 Series/C200 Series Chipset Family 6 port Desktop SATA AHCI Controller (rev 04)
00:1f.3 SMBus: Intel Corporation 6 Series/C200 Series Chipset Family SMBus Controller (rev 04)
03:00.0 Unassigned class [ff00]: Microsoft Corporation Device b100 (rev 01)
04:00.0 USB controller: NEC Corporation uPD720200 USB 3.0 Host Controller (rev 04)
05:03.0 FireWire (IEEE 1394): LSI Corporation FW322/323 [TrueFire] 1394a Controller (rev 70)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Using &lt;code&gt;lspci -vv&lt;/code&gt; to get more information, we see that the link is established
at 2.5 GT/s (probably too many connectors in series to go faster) and at
x1 width (as expected, since we only pass one lane through the USB cable):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo lspci -s 03:00 -vv
03:00.0 Unassigned class [ff00]: Microsoft Corporation Device b100 (rev 01)
    Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;PERR- INTx-
    Latency: 0, Cache Line Size: 64 bytes
    Interrupt: pin A routed to IRQ 11
    Region 0: Memory at fa000000 (32-bit, non-prefetchable) [size=16M]
    Region 2: Memory at fb000000 (32-bit, non-prefetchable) [size=1K]
    Capabilities: [50] MSI: Enable- Count=1/4 Maskable- 64bit+
        Address: 0000000000000000  Data: 0000
    Capabilities: [78] Power Management version 3
        Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot-,D3cold-)
        Status: D0 NoSoftRst- PME-Enable- DSel=0 DScale=0 PME-
    Capabilities: [80] Express (v2) Endpoint, MSI 00
        DevCap: MaxPayload 256 bytes, PhantFunc 0, Latency L0s &amp;lt;64ns, L1 &amp;lt;1us
            ExtTag- AttnBtn- AttnInd- PwrInd- RBE+ FLReset- SlotPowerLimit 10.000W
        DevCtl: CorrErr- NonFatalErr- FatalErr- UnsupReq-
            RlxdOrd- ExtTag- PhantFunc- AuxPwr- NoSnoop+
            MaxPayload 128 bytes, MaxReadReq 128 bytes
        DevSta: CorrErr+ NonFatalErr- FatalErr- UnsupReq+ AuxPwr- TransPend-
        LnkCap: Port #1, Speed 8GT/s, Width x8, ASPM not supported
            ClockPM- Surprise- LLActRep- BwNot- ASPMOptComp+
        LnkCtl: ASPM Disabled; RCB 64 bytes Disabled- CommClk+
            ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
        LnkSta: Speed 2.5GT/s (downgraded), Width x1 (downgraded)
            TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-
        DevCap2: Completion Timeout: Range ABCD, TimeoutDis+, NROPrPrP-, LTR-
             10BitTagComp-, 10BitTagReq-, OBFF Not Supported, ExtFmt-, EETLPPrefix-
             EmergencyPowerReduction Not Supported, EmergencyPowerReductionInit-
             FRS-, TPHComp-, ExtTPHComp-
             AtomicOpsCap: 32bit- 64bit- 128bitCAS-
        DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis-, LTR-, OBFF Disabled
             AtomicOpsCtl: ReqEn-
        LnkCtl2: Target Link Speed: 8GT/s, EnterCompliance- SpeedDis-
             Transmit Margin: Normal Operating Range, EnterModifiedCompliance- ComplianceSOS-
             Compliance De-emphasis: -6dB
        LnkSta2: Current De-emphasis Level: -3.5dB, EqualizationComplete-, EqualizationPhase1-
             EqualizationPhase2-, EqualizationPhase3-, LinkEqualizationRequest-
    Capabilities: [100 v1] Virtual Channel
        Caps:   LPEVC=0 RefClk=100ns PATEntryBits=1
        Arb:    Fixed- WRR32- WRR64- WRR128-
        Ctrl:   ArbSelect=Fixed
        Status: InProgress-
        VC0:    Caps:   PATOffset=00 MaxTimeSlots=1 RejSnoopTrans-
            Arb:    Fixed- WRR32- WRR64- WRR128- TWRR128- WRR256-
            Ctrl:   Enable+ ID=0 ArbSelect=Fixed TC/VC=01
            Status: NegoPending- InProgress-
    Capabilities: [200 v1] Vendor Specific Information: ID=0000 Rev=0 Len=044 &amp;lt;?&amp;gt;
    Capabilities: [300 v1] Secondary PCI Express
        LnkCtl3: LnkEquIntrruptEn-, PerformEqu-
        LaneErrStat: 0
    Capabilities: [800 v1] Advanced Error Reporting
        UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
        UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
        UESvrt: DLP+ SDES+ TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-
        CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-
        CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+
        AERCap: First Error Pointer: 00, ECRCGenCap- ECRCGenEn- ECRCChkCap- ECRCChkEn-
            MultHdrRecCap- MultHdrRecEn- TLPPfxPres- HdrLogCap-
        HeaderLog: 00000000 00000000 00000000 00000000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;Summary and outlook&lt;/h1&gt;
&lt;p&gt;The adapter card did its job and provided access to the I2C bus and a connection
to the PCI Express. I have managed to parse the content of the EEPROM (and
realize that there is nothing interesting there) and establish the PCIe
connection to the FPGA, as a first step of getting the hardware ready for custom
developments.&lt;/p&gt;
&lt;p&gt;Eventually I plan to develop a card with a wider PCIe link and get rid of the
USB cable setup.&lt;/p&gt;
&lt;p&gt;There were some mistakes on the adapter board (rotated Samtec connector, swapped
TX and RX on the USB connector) which I could work around, and serve as a lesson
to be more careful next time and double-check everything.&lt;/p&gt;
&lt;p&gt;As the next step, I would like to understand better how the JTAG chip works. I
know that it can be used with OpenOCD, but I would imagine that one can somehow
also make it talk to Quartus directly.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;All trademarks and registered trademarks are the property of their respective owners.&lt;/p&gt;&lt;script src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;</content><category term="FPGA"></category></entry><entry><title>Stratix V accelerator card from eBay</title><link href="www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay.html" rel="alternate"></link><published>2020-05-03T14:30:00+02:00</published><updated>2020-05-03T14:30:00+02:00</updated><author><name>Jan Marjanovic</name></author><id>tag:None,2020-05-03:www.j-marjanovic.io/stratix-v-accelerator-card-from-ebay.html</id><summary type="html">&lt;p&gt;A couple of weeks ago &lt;a href="https://twitter.com/rombik_su"&gt;@rombik_su&lt;/a&gt; in a &lt;a href="https://twitter.com/rombik_su/status/1250382904074608642"&gt;Twitter
thread&lt;/a&gt; pointed out a
very cheap FPGA accelerator card on eBay. The board contains a proprietary
Samtec board-to-board connector, most likely carrying power, PCI Express, and
auxiliary signals (JTAG, IPMI to BMC, ...), two QSFP cages, DDR3 and a large
FPGA, hidden …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A couple of weeks ago &lt;a href="https://twitter.com/rombik_su"&gt;@rombik_su&lt;/a&gt; in a &lt;a href="https://twitter.com/rombik_su/status/1250382904074608642"&gt;Twitter
thread&lt;/a&gt; pointed out a
very cheap FPGA accelerator card on eBay. The board contains a proprietary
Samtec board-to-board connector, most likely carrying power, PCI Express, and
auxiliary signals (JTAG, IPMI to BMC, ...), two QSFP cages, DDR3 and a large
FPGA, hidden under the heatsink.&lt;/p&gt;
&lt;p&gt;Being passionate about everything FPGA-related, and with Coronavirus lockdown
limiting the number of fun things to do, I decided to purchase the board. An
evaluation kit of this kind can easily cost thousands, and 40 USD is a real
bargain.&lt;/p&gt;
&lt;h2&gt;Initial research&lt;/h2&gt;
&lt;p&gt;While waiting for the board to arrive, I did some initial investigation. The
description on eBay is quite cryptic. The title of the listing included all the
text from the labels on the board, including the label "AIRFLOW" indicating
the direction of the forced air through the board.&lt;/p&gt;
&lt;p&gt;One of the most fruitful clues was the label "Microsoft" on the board. It was
well-publicized a couple of years ago that Microsoft is using FPGAs to
accelerate Bing searches, and this might be one of the boards used in the
servers.&lt;/p&gt;
&lt;p&gt;Remembering that Microsoft went with Altera (now Intel PSG) and that this was
some years back, it is most likely that the card contains a Stratix V FPGA.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://www.microsoft.com/en-us/research/uploads/prod/2014/06/HC26.12.520-Recon-Fabric-Pulnam-Microsoft-Catapult.pdf"&gt;first
link&lt;/a&gt;
on Google (or should I have used Bing? would the FPGAs be aware that I am
looking for information about them?) for "microsoft catapult stratix v"
presented some conceptually similar cards, but not exactly the same.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/10/Cloud-Scale-Acceleration-Architecture.pdf"&gt;second
link&lt;/a&gt;,
however, presented the exact card which I have purchased:&lt;/p&gt;
&lt;p&gt;&lt;img alt="FPGA card, from A. Caulfield et al: A Cloud-Scale Acceleration Architecture" src="www.j-marjanovic.io/images/2020_fpga_card/img-002.jpg" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;&lt;small&gt;(from A. Caulfield et al: A Cloud-Scale Acceleration Architecture)&lt;/small&gt;&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;The paper also contains a block diagram highlighting the main components
of the board:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Block diagram, from A. Caulfield et al: A Cloud-Scale Acceleration Architecture" src="www.j-marjanovic.io/images/2020_fpga_card/block_diagram.png" style="width:60%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/p&gt;
&lt;div style="text-align: center;"&gt;&lt;small&gt;(from A. Caulfield et al: A Cloud-Scale Acceleration Architecture)&lt;/small&gt;&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;The paper also mentions "widely-used OpenCompute server" which could give out
some information about the pinout on the Samtec connector. Since there are
numerous formats for mezzanine cards standardized by the OpenCompute project,
and finding the matching one is not trivial, I decided to leave this task for
later.&lt;/p&gt;
&lt;p&gt;Further digging in the search results, I was also able to find &lt;a href="https://mspoweruser.com/microsoft-talks-about-the-project-that-helped-them-build-the-worlds-first-ai-supercomputer/"&gt;another photo&lt;/a&gt;
of the board with the heatsink removed.&lt;/p&gt;
&lt;p&gt;The marking on the FPGA are removed, but we already know that it is a Stratix V,
and some things were expected from previous documents, e.g. 5 DDR3 chips for
a combined of 9 chips for 72-bit DDR3 data width).&lt;/p&gt;
&lt;p&gt;What I found interesting in this picture is a Flash memory (Micron 25Q256) in
the top right corner, which means that the image for the FPGA is most likely
stored on the board and is not downloaded through the connector at the startup.
It is also possible that &lt;a href="https://www.intel.com/content/www/us/en/programmable/support/support-resources/support-centers/devices/cfg-index/cfg-via-protocol.html"&gt;Configuration via
Protocol&lt;/a&gt;
is used, and only the basic image is stored in the Flash.&lt;/p&gt;
&lt;h1&gt;Board overview&lt;/h1&gt;
&lt;p&gt;Then one day, the board finally arrives. The board matches the description
in the previously-mentioned article.&lt;/p&gt;
&lt;p&gt;A quick look at the board identifies the following components:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;160 pin Samtec SEARAY™ connector&lt;/li&gt;
&lt;li&gt;USB (FT232H, used as a JTAG interface)&lt;/li&gt;
&lt;li&gt;power entry (FDMS0310AS MOSFET, 0.01 Ohm resistor, unidentified IC with the markings "L536FCD")&lt;/li&gt;
&lt;li&gt;power converters (Enpirion® EN2342QI DC-DC converter)&lt;/li&gt;
&lt;li&gt;programmable oscillator (IDT8N4Q001)&lt;/li&gt;
&lt;li&gt;Flash memory for FPGA (Micron N25Q256A)&lt;/li&gt;
&lt;li&gt;I2C EEPROM (ST M24128-BW)&lt;/li&gt;
&lt;li&gt;DDR3 memory (SK hynix H5TC4G83BFR)&lt;/li&gt;
&lt;/ul&gt;
&lt;p style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="The board with annotated sections" src="www.j-marjanovic.io/images/2020_fpga_card/9560_annotated.jpg"&gt;&lt;/p&gt;
&lt;h1&gt;USB/JTAG&lt;/h1&gt;
&lt;p&gt;At this point, it was time to start experimenting with the board. The FT232H
seems to be powered from the USB BUS voltage: pin 1 of J3 is connected to pin 40
(VREGIN) of FT232H. This is why I decided to first start with the USB. With the
datasheet for FT232H it was trivial to determine the pin assignments on the
connector. I did not want to solder directly on the connector pins, as I would
like to make a proper cable in the future.&lt;/p&gt;
&lt;p style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="USB connection with signal annotations" src="www.j-marjanovic.io/images/2020_fpga_card/9570_annotated.jpg"&gt;&lt;/p&gt;
&lt;p&gt;After plugging the cable in the computer, the FT232H is recognized as "USB
Serial Converter":&lt;/p&gt;
&lt;p style="width:40%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="Driver information about the FT232H" src="www.j-marjanovic.io/images/2020_fpga_card/device_manager2.png"&gt;&lt;/p&gt;
&lt;h1&gt;Connector, 1st look&lt;/h1&gt;
&lt;p&gt;At this point I could start trying to reverse engineer the connector pinout. I
managed to figure out the following connections:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ground&lt;/li&gt;
&lt;li&gt;Input power: there are a couple of pins connected to the Drain of the large
    MOSFET. I also assume that the level is, as it is common for PCIe cards,
    12V.&lt;/li&gt;
&lt;li&gt;There are 16 pairs of AC-coupling capacitors near the connector. PCIe
    standard mandates capacitors on the TX side, so I assume this is PCIE_TX.
    Not knowing the exact lane numbering, I decided to enumerate them with
    letters instead of numbers.&lt;/li&gt;
&lt;li&gt;PCIe RX is TBD, but looking at unassigned pins a clear pattern is visible&lt;/li&gt;
&lt;li&gt;Some of the pins are connected to the circuit above the connector - I have
    annotated these pins, but right now I do not have a clear idea what is the
    purpose. I annotated those pins as AUX.&lt;/li&gt;
&lt;/ul&gt;
&lt;p style="width:100%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="Samtec connector with partial pinout, 1" src="www.j-marjanovic.io/images/2020_fpga_card/pinout_1.png"&gt;&lt;/p&gt;
&lt;h1&gt;Power&lt;/h1&gt;
&lt;p&gt;I have connected the 12V on the Drain side of the Q12 (FDMS0310AS), which has
also energized the PU12 and +12V pins on the Samtec connector. However, the
power consumption was only 3 mA, and the MOSFET was left closed.&lt;/p&gt;
&lt;p&gt;I could not find any information about PU12 (L536FCD). I assume it is some
kind of a current-limit protection, measuring the current through the 0.01 Ohm
shunt resistor and controlling the Gate pin of Q12.&lt;/p&gt;
&lt;p&gt;To literally bypass this problem, I have decided to also connect 12 V on the
other side of the Q12. This yielded some results; the power consumption raised
to 695 mA, which is what one would expect from such board, and the LEDs turned
on. &lt;/p&gt;
&lt;p style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="Power consumption" src="www.j-marjanovic.io/images/2020_fpga_card/fr_9586_size1024.jpg"&gt;&lt;/p&gt;
&lt;p&gt;On various points in the circuit I could also measure all the voltages one
would expect to find in such a circuit:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.5V on the Enpirion (PU16) output&lt;/li&gt;
&lt;li&gt;1.35 V on C406 (DDR3 voltage)&lt;/li&gt;
&lt;li&gt;0.674 V on C1005 (DDR3 termination voltage)&lt;/li&gt;
&lt;li&gt;2.5 V on C442 (periphery)&lt;/li&gt;
&lt;li&gt;3.3 V on QSFP capacitors&lt;/li&gt;
&lt;li&gt;0.9 V on C354 (FPGA core voltage)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Memories&lt;/h1&gt;
&lt;h2&gt;FPGA configuration memory&lt;/h2&gt;
&lt;p&gt;The heatsink covers the large part of the top side of the board including the
Flash memory for the FPGA configuration. One can, however, still reach the pins
8 and 9 (DQ1 and DQ2, respectively) with an oscilloscope probe.&lt;/p&gt;
&lt;p&gt;After the power is applied to the board, we can observe that the FPGA gets
programmed in roughly a second. This is above the 100 ms/200 ms limit required
by the PCIe standard, but in this custom form factor the value might be
different.&lt;/p&gt;
&lt;p&gt;DQ2 pin on N25Q256A:&lt;/p&gt;
&lt;p style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="Data from DQ2 pin after power up" src="www.j-marjanovic.io/images/2020_fpga_card/mem_top_left_pin.png"&gt;&lt;/p&gt;
&lt;p&gt;LEDs on the board are also driven by the FPGA and remain lit for a second until
the FPGA is not programmed, another indication that the FPGA gets configured
from the memory.&lt;/p&gt;
&lt;h2&gt;EEPROM&lt;/h2&gt;
&lt;p&gt;Another memory on the board is a small 128Kbit EEPROM, which probably stores MAC
addresses, serial numbers, and other similar information.&lt;/p&gt;
&lt;p&gt;Quite interestingly, SDA and SCL lines remain stuck low after some time.
Maybe the EEPROM is not used at all, or maybe there is some other part
of the circuit is keeping the EEPROM interface state machine in a reset.&lt;/p&gt;
&lt;p&gt;SDA pin on M24128-BW, SCL is very similar:&lt;/p&gt;
&lt;p style="width:80%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="SDA pin on M24128-BW" src="www.j-marjanovic.io/images/2020_fpga_card/M24128_SDA.png"&gt;&lt;/p&gt;
&lt;h1&gt;Connector, 2nd look&lt;/h1&gt;
&lt;p&gt;With the board powered on, I could measure the voltage on the connector pins.
As expected, on 16 differential pairs I can sense a bias voltage of the PCIe
receivers, around 0.7 V.&lt;/p&gt;
&lt;p&gt;Some of the AUX pins have a slight bias, but this is probably caused by
pull-up resistors and other components. It would require more investigation
to fully understand the purpose of these pins.&lt;/p&gt;
&lt;p style="width:100%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="Samtec connector with partial pinout, 2" src="www.j-marjanovic.io/images/2020_fpga_card/pinout_2.png"&gt;&lt;/p&gt;
&lt;h1&gt;Components&lt;/h1&gt;
&lt;h2&gt;QSFP&lt;/h2&gt;
&lt;p&gt;Plugging in a QSFP cable only marginally increases the power consumption.
It is clear that the high-speed circuit is disabled, most likely because
of an internal register configuration and less likely because the cable
is "not compatible", i.e. the board parses the EEPROM and it does not enable
the high-speed circuit.&lt;/p&gt;
&lt;p&gt;Consumption from the 12V input:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;without the QSFP module inserted: 696.7 mA&lt;/li&gt;
&lt;li&gt;with the QSFP module inserted: 697.5 mA&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;IDT oscillator&lt;/h2&gt;
&lt;p&gt;IDT oscillator is producing 645 MHz clock.&lt;/p&gt;
&lt;h2&gt;DDR3&lt;/h2&gt;
&lt;p&gt;I have probed what I presume are the DDR3 termination resistors (on the bottom
side, on the other side of the 5th DDR3 component on the top) and observed
no switching activity. It seems that the DDR3 controller is kept in reset.&lt;/p&gt;
&lt;h1&gt;Outlook&lt;/h1&gt;
&lt;p&gt;The first bring-up session was quite successful; I have managed to turn on the
board without damaging it and figure out the basic pinout of the connector.&lt;/p&gt;
&lt;p&gt;For the next step, I plan to investigate the OpenCompute website if there exists
a document that would describe the pinout of the connector. Still left to be
determined are the reference clock and an enable signal from the connector.&lt;/p&gt;
&lt;p&gt;Eventually I plan to produce a small PCB that would allow plugging this board
in a normal PCIe card slot.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;All trademarks and registered trademarks are the property of their respective owners.&lt;/p&gt;&lt;script src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;</content><category term="FPGA"></category></entry></feed>