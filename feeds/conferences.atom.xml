<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>j-marjanovic.io - Conferences</title><link href="www.j-marjanovic.io/" rel="alternate"></link><link href="www.j-marjanovic.io/feeds/conferences.atom.xml" rel="self"></link><id>www.j-marjanovic.io/</id><updated>2019-02-03T20:10:00+01:00</updated><entry><title>Notes from FOSDEM 2019</title><link href="www.j-marjanovic.io/notes-from-fosdem-2019.html" rel="alternate"></link><published>2019-02-03T20:10:00+01:00</published><updated>2019-02-03T20:10:00+01:00</updated><author><name>Jan Marjanovic</name></author><id>tag:None,2019-02-03:www.j-marjanovic.io/notes-from-fosdem-2019.html</id><summary type="html">&lt;p&gt;I attended FOSDEM 2019 in Brussels:&lt;/p&gt;
&lt;p style="width:40%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="Brussels" src="www.j-marjanovic.io/images/fosdem2019.jpg"&gt;&lt;/p&gt;
&lt;p&gt;and these are my notes from Quantum Computers, CAD and Open Hardware
and Python tracks:&lt;/p&gt;
&lt;h1&gt;Quantum Computing&lt;/h1&gt;
&lt;h2&gt;Delivering Practical Quantum Computing on the D-Wave System&lt;/h2&gt;
&lt;h3&gt;Intro&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;marketing slide for D-Wave Leap&lt;/li&gt;
&lt;li&gt;practical = Adiabatic Quantum computer&lt;/li&gt;
&lt;li&gt;Riggeti uses gate model instead&lt;/li&gt;
&lt;li&gt;physical impl: 3 m â€¦&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;I attended FOSDEM 2019 in Brussels:&lt;/p&gt;
&lt;p style="width:40%; display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img alt="Brussels" src="www.j-marjanovic.io/images/fosdem2019.jpg"&gt;&lt;/p&gt;
&lt;p&gt;and these are my notes from Quantum Computers, CAD and Open Hardware
and Python tracks:&lt;/p&gt;
&lt;h1&gt;Quantum Computing&lt;/h1&gt;
&lt;h2&gt;Delivering Practical Quantum Computing on the D-Wave System&lt;/h2&gt;
&lt;h3&gt;Intro&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;marketing slide for D-Wave Leap&lt;/li&gt;
&lt;li&gt;practical = Adiabatic Quantum computer&lt;/li&gt;
&lt;li&gt;Riggeti uses gate model instead&lt;/li&gt;
&lt;li&gt;physical impl: 3 m high box + 3 normal racks&lt;/li&gt;
&lt;li&gt;QPU (Quantum Processor Unit): 16x16 grid&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;theory&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;language&lt;ul&gt;
&lt;li&gt;qubit&lt;/li&gt;
&lt;li&gt;coupler (either both in same direction or opposite)&lt;/li&gt;
&lt;li&gt;weights (? initial state)&lt;/li&gt;
&lt;li&gt;strength (for couplers)&lt;/li&gt;
&lt;li&gt;objective (function which gets minimized)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BQM (?)&lt;/li&gt;
&lt;li&gt;5 us annealing&lt;/li&gt;
&lt;li&gt;problems: noise&lt;/li&gt;
&lt;li&gt;noise can bring you in more than one solution (might be useful for some problems)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Markets&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;portfolio&lt;/li&gt;
&lt;li&gt;internet ad&lt;/li&gt;
&lt;li&gt;high-energy physics&lt;/li&gt;
&lt;li&gt;image recognition&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Q &amp;amp; A&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;clock speed -&amp;gt; no clock speed&lt;/li&gt;
&lt;li&gt;total computation time -&amp;gt; 5 us to 1 s&lt;/li&gt;
&lt;li&gt;Pegasus: proposed arch for a new machine&lt;/li&gt;
&lt;li&gt;new Hamiltonioan in Pegasus&lt;/li&gt;
&lt;li&gt;error corrections: from 2048 bits, no error corrections because of what
  they calculate&lt;/li&gt;
&lt;li&gt;classical solutions vs quantum solutions: wall-clock time is the benchmark&lt;/li&gt;
&lt;li&gt;hello world: &lt;/li&gt;
&lt;li&gt;D-Wave: not a threat for a normal crypto (factoring a number is not a good problem)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;D-Wave's Software Development Kit&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;tools and utilities for QC development&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;motivation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;solution space is "smooth": good solutions are "grouped together"&lt;/li&gt;
&lt;li&gt;step 1: problem as polynomial&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;equation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;b-terms: linear bias&lt;/li&gt;
&lt;li&gt;a-terms: quadratic bias&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Quantum Machine Instr: biases in certain range: because of physical limitaiton?
* Chimera graph and Pegasus graph&lt;/p&gt;
&lt;h3&gt;Ocean software&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Python front-end, C++ for high performance&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mapping methods&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;samplers&lt;/li&gt;
&lt;li&gt;compute resources&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;dimod&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;API for samplers&lt;/li&gt;
&lt;li&gt;BQM&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;cloud client&lt;/h4&gt;
&lt;h4&gt;minorminer&lt;/h4&gt;
&lt;h4&gt;dwavebinaryscp&lt;/h4&gt;
&lt;p&gt;constraint satisfaction&lt;/p&gt;
&lt;h4&gt;dwave-networkx&lt;/h4&gt;
&lt;p&gt;graph theory problem,
same API as networkx&lt;/p&gt;
&lt;h3&gt;Steps&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;translate to binary&lt;/li&gt;
&lt;li&gt;define BQM function&lt;/li&gt;
&lt;li&gt;BQM to matrix form&lt;/li&gt;
&lt;li&gt;BQM through sampler&lt;/li&gt;
&lt;li&gt;post-processing and interpretation&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;pip install dwave-ocean-sdk&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Q &amp;amp; A&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;resolution: 0.01 resolution&lt;/li&gt;
&lt;li&gt;Fujitsu and Hitachi: another providers&lt;/li&gt;
&lt;li&gt;8 couplers per qbit&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;D-Wave Hybrid Framework&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;decomposition -&amp;gt; split the problem to fit into BQM&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;github.com/dwavesystems/dwave-hybrid&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;solver/sampler framework&lt;/li&gt;
&lt;li&gt;uses both quantum and classical resources&lt;/li&gt;
&lt;li&gt;dataflow paradigm&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;What is IBMQ&lt;/h2&gt;
&lt;h3&gt;quantum algorithms&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;current algorithms --&amp;gt; quantum algorithms&lt;/li&gt;
&lt;li&gt;supra-polynomial speed-up&lt;/li&gt;
&lt;li&gt;Schor's algorithm: polynomial time for factoring of the numbers&lt;/li&gt;
&lt;li&gt;simulating quantum mechanics (Hamiltonian equations); for chemistry&lt;/li&gt;
&lt;li&gt;factoring 1024-bit number: hours with QC&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;how to program a QC: mapping interference pattern on qbits&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;entanglement -&amp;gt; consistent quantum system -&amp;gt; colapse&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;every quantum program: circuit (no feedback!)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;result is non deterministic (robust algorithms provide good results)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;quantum volume (metric used at IBM)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;coherence time: 100s of us&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;technology is quantum ready&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;quantum technologies&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;superconductive Josephson junction&lt;/li&gt;
&lt;li&gt;entaglion (only hypothetical?)&lt;/li&gt;
&lt;li&gt;QASM (quantum assembly language)&lt;/li&gt;
&lt;li&gt;5 GHz, 240 mK, low noise&lt;/li&gt;
&lt;li&gt;all QC look similar: only way to do it&lt;/li&gt;
&lt;li&gt;current state: oscilloscopes, signal generators, ...&lt;/li&gt;
&lt;li&gt;pizza box for controlling the QC in the future&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;quantum advantage&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;IBM provides a lot of stuff on their GitHub&lt;/li&gt;
&lt;li&gt;Jupyter notebooks, vscode plugin&lt;/li&gt;
&lt;li&gt;Quiskit Acua: example problem: bonding energy for a molecule &lt;/li&gt;
&lt;li&gt;Quiskit Aer: ...&lt;/li&gt;
&lt;li&gt;publicly available QC&lt;/li&gt;
&lt;li&gt;gate error and readout error are publicly available (~1e-3 for the example)&lt;/li&gt;
&lt;li&gt;IBM has several QC architectures (Tokyo, Melburne)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Q &amp;amp; A&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;noise problems for QC, do qbits produce noise -&amp;gt; engineering will find a solution&lt;/li&gt;
&lt;li&gt;quantum volue of Tokyo -&amp;gt; "the best, it is not just the number of qbits"&lt;/li&gt;
&lt;li&gt;Quiskit Aqua: chemistry API&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;CAD and Open Hardware&lt;/h1&gt;
&lt;h2&gt;gnucap&lt;/h2&gt;
&lt;h3&gt;intro&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;mixed-signal simulator&lt;/li&gt;
&lt;li&gt;prototype for Verilog-AMS (~10 years ago)&lt;/li&gt;
&lt;li&gt;analog circuits and digital circuits simulators are different (transient vs event-based)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;analog circuit simulation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;node equations --&amp;gt; matrix form&lt;/li&gt;
&lt;li&gt;often: differential equations, Newton iteration&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;digital circuit simulation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;event based, with evaluation queue&lt;/li&gt;
&lt;li&gt;can be used&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Gnucap&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Gnucap decompose the circuit matrix into L and U&lt;/li&gt;
&lt;li&gt;Gnucap keeps track of the changes to the matrix, schedules an update to
  the circuit matrix &lt;/li&gt;
&lt;li&gt;bypass = not computing something&lt;/li&gt;
&lt;li&gt;Gnucap uses all the tricks to calculate inverse of the matrix (pivoting)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;architecture of Gnucap&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;the concept (matrix solving + event-based updates) is tighly integrated
  in the codebase&lt;/li&gt;
&lt;li&gt;plugin infrasctructure: modeling languages (VHDL, Verilog-AMS, SystemC considered)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shared library for basic s&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;compoenents are plugins (dlopen)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;components&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;commands&lt;/li&gt;
&lt;li&gt;algorithms &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;plugins&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Turing complete&lt;/li&gt;
&lt;li&gt;examples of plugins&lt;/li&gt;
&lt;li&gt;import module (python)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;insmod module (linux)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gnucap-python&lt;/code&gt;, e.g. Jupyter, user can access internal data, use Scipy, ...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Verilog-A in QUCS/gnucsator&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;license for models&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Gnucap supports models from other sources&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;two types:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;distributed as source code: --&amp;gt; just log it into the Gnucap (no issues)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;distributed as binary: --&amp;gt; wrapper + blob&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;summary&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;mixed-mode is faster&lt;/li&gt;
&lt;li&gt;more front-end work needed&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;ngspice&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;talk is not about the details, but about the framework, user interface and future&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;intro&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;input: standard SPICE text inpu&lt;/li&gt;
&lt;li&gt;output: transient simulator &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;successor of spice3f5 from Berkley&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;three flavors:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;standard executable: CLI, file and graphics output, control language&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;shared library for tcl/tk (not used so much)&lt;/li&gt;
&lt;li&gt;C shared library (so/dll): input and output via callbacks&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;scripting language&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;its own library (developer don't like python)&lt;/li&gt;
&lt;li&gt;94 commands, math functions, loops, ...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;device models&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;hard-coded models (BJS, MOS, JFET, xFET, trans lines, Verilog A interface via adms)&lt;/li&gt;
&lt;li&gt;B source with build-in function&lt;/li&gt;
&lt;li&gt;XSPICE shared library (written in C, both analog and digital)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;application areas&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PCB design&lt;/li&gt;
&lt;li&gt;mix of ICs and discrete components&lt;/li&gt;
&lt;li&gt;requires a comfortable user interface (offered by 3rd parties - e.g. KiCAD)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PSPICE and LTSPICE model requirements&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IC design&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;models from the foundries (very reliable but complex)&lt;/li&gt;
&lt;li&gt;supports HSPICE&lt;/li&gt;
&lt;li&gt;MOS models, large circuits, certain speed&lt;/li&gt;
&lt;li&gt;integration with other tools ongoing&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;mixed-signal capabilities&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;from XSPICE&lt;/li&gt;
&lt;li&gt;digital: event based, signal strengths and delays&lt;/li&gt;
&lt;li&gt;analog: C coded models, time and freq domain&lt;/li&gt;
&lt;li&gt;simple example: digital is 50x faster than analog&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;experimental developments&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;KLU solver: 2x, 3x faster&lt;/li&gt;
&lt;li&gt;CUDA for GPU: development on-going&lt;/li&gt;
&lt;li&gt;Cider: 1D and 2D TCAD: device structure, solve physics equations&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;licenses&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;core: BSD, LGPL, ... no issues&lt;/li&gt;
&lt;li&gt;Verilog A models: more complicated&lt;/li&gt;
&lt;li&gt;vendor devices: can be used, but not distributed&lt;/li&gt;
&lt;li&gt;IC model data: PDKs are under NDA (also encryption)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;future&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;unicode&lt;/li&gt;
&lt;li&gt;some commands (pz, ...)&lt;/li&gt;
&lt;li&gt;integration with other tools and flows&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;openEMS - An Introduction and Overview&lt;/h2&gt;
&lt;h3&gt;intro&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;FOSS solver for electromagnetics fields&lt;/li&gt;
&lt;li&gt;simulate and evaluate RF and optical devices&lt;/li&gt;
&lt;li&gt;uses FDTD (finite differences in time domain)&lt;/li&gt;
&lt;li&gt;co-ordinate systems: cylindrial and cartesian&lt;/li&gt;
&lt;li&gt;lumped elements available&lt;/li&gt;
&lt;li&gt;human body models&lt;/li&gt;
&lt;li&gt;dispersive models&lt;/li&gt;
&lt;li&gt;support for remote simulation (cluster)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;show cases&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;notch filter, very nice demo&lt;/li&gt;
&lt;li&gt;examples: helical antena, antenna array, MRI antenna design (loop coils)&lt;/li&gt;
&lt;li&gt;small size PCB antenna&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;interfacing&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;nice to have: interface to PCB editors&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;problem: link (between EMS and PCB editors) is very week&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;some examples:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;hyp2mat&lt;/li&gt;
&lt;li&gt;pcb-rnd&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pcbmodelgen (KiCAD to openEMS)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ultimate goal: Circuit simulation &amp;lt;--&amp;gt; PCB design &amp;lt;--&amp;gt; RF simulation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;status&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;openEMS is a mature EM simulation package&lt;/li&gt;
&lt;li&gt;TODO list: improve the documentation, interface to tools, ...&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Project Trellis and nextpnr&lt;/h2&gt;
&lt;h3&gt;ECP5&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;85k logic cells (4 LUTS, FF, carry), block RAM, 18x18 DSPs, SERDES (up to 5 GTs)&lt;/li&gt;
&lt;li&gt;split into tiles, tiles split into slices&lt;/li&gt;
&lt;li&gt;fixed wires&lt;/li&gt;
&lt;li&gt;arcs and pip&lt;/li&gt;
&lt;li&gt;all arcs and wires are undirectional - mux topology&lt;/li&gt;
&lt;li&gt;dedicated clock network&lt;/li&gt;
&lt;li&gt;programmable interconnect: pass gates (cascade of 2 mux)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;status&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;bit and routing done&lt;/li&gt;
&lt;li&gt;missing: DSP&lt;/li&gt;
&lt;li&gt;timing documentation for fabric, logic cells, RAM, ...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;text configuration format&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;tools to convert from and to bitstream&lt;/li&gt;
&lt;li&gt;intermediate format for place &amp;amp; route&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;timing&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;not enought vendor support&lt;/li&gt;
&lt;li&gt;delays for the cells extracted from SDF files&lt;/li&gt;
&lt;li&gt;routing delay obtained using least-squares from reports for entire net&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;workflow&lt;/h3&gt;
&lt;h4&gt;yosys&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;support ECP5, iCE40, Xilinx, ...&lt;/li&gt;
&lt;li&gt;uses Berkley ABC for logic optimization&lt;/li&gt;
&lt;li&gt;formal equivalence checking, assertions&lt;/li&gt;
&lt;li&gt;....&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;nextpnr&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;replacement for arachnepnr&lt;/li&gt;
&lt;li&gt;developments from May 2018&lt;/li&gt;
&lt;li&gt;timing-driven&lt;/li&gt;
&lt;li&gt;architecture implements an API: useful for different architectures&lt;/li&gt;
&lt;li&gt;each arch has its own binary: a lot of optimization possible&lt;/li&gt;
&lt;li&gt;7-series is VERY experimental (more work planned)&lt;/li&gt;
&lt;li&gt;first implementation:&lt;/li&gt;
&lt;li&gt;SA placer&lt;/li&gt;
&lt;li&gt;A*+ripup router&lt;/li&gt;
&lt;li&gt;future&lt;/li&gt;
&lt;li&gt;analyty placer&lt;/li&gt;
&lt;li&gt;SAT-based placer,&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;li&gt;nice graphical interface&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Design Automation in Wonderland&lt;/h2&gt;
&lt;h3&gt;intro&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;motivation and goals&lt;/li&gt;
&lt;li&gt;reuse common functionality&lt;/li&gt;
&lt;li&gt;easy to integrate, easy to adapt libraries&lt;/li&gt;
&lt;li&gt;a set of modular libraries&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;based on Berkley ABC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;use C++14 or C++17&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;header-only&lt;/li&gt;
&lt;li&gt;well documented, well tested&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;libraries&lt;/h3&gt;
&lt;h4&gt;lorina: parsing library&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;can pasrse very simple Verilog&lt;/li&gt;
&lt;li&gt;parser reads Verilog and provides data to mockturtle&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;mockturtle: logic network library&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;network interface API&lt;/li&gt;
&lt;li&gt;logic synth, opt, technology mapping&lt;/li&gt;
&lt;li&gt;impelementations: and-inverted, kLUT, ...&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;performance tweeks&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cut the combinatorial network into LUTs, based on cost function (speed/area)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;kitty: truth table&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;manipulation of truth table&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;percy: exact synthesis library&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;re-synthesis&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;conclusion&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;exctract the logic function&lt;/li&gt;
&lt;li&gt;optimization&lt;/li&gt;
&lt;li&gt;mapping to tech&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;github.com/lsils&lt;/p&gt;
&lt;h2&gt;Open source virtual prototyping for faster hardware and software co-design&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;virtual prototyping &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;current development&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;idea&lt;/li&gt;
&lt;li&gt;SW and HW developed in parallel&lt;/li&gt;
&lt;li&gt;integration&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;virtual prototype&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;idea&lt;/li&gt;
&lt;li&gt;virtual prototype --&amp;gt; SW can be developed in parallel&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;virtual prototyping: SW environment simulating the HW&lt;/p&gt;
&lt;h3&gt;example&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;model entire SoC (RPi: quad core, peripheral)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;issues:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;models (of the IP) are hard to find&lt;/li&gt;
&lt;li&gt;too much components --&amp;gt; needs to be done: shared effort&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;?&lt;/h3&gt;
&lt;p&gt;"interoperability is the key" --&amp;gt; take advantage of the community&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;toolchain: marketplace for components, GUI, ...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Q &amp;amp; A&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;interface with SystemC and TLM: support for TLM is there&lt;/li&gt;
&lt;li&gt;modules: how to verify the model: ?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Lesson learned from Retro-uC and search for ideal HDL for open source silicon&lt;/h2&gt;
&lt;h3&gt;intro&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;idea: open source microcontroller (Z80, MOS 65 and 68000, 3 uC in one chip)&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;a development board&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;"VHDL and Verilog are not the right tools for the job"&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;RTL faults&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;clock is logic signal&lt;/li&gt;
&lt;li&gt;if --&amp;gt; mux or flip-flop&lt;/li&gt;
&lt;li&gt;synth vs non-synth&lt;/li&gt;
&lt;li&gt;Verilog: block and non-blocking&lt;/li&gt;
&lt;li&gt;FPGA vs ASIC&lt;/li&gt;
&lt;li&gt;RTFLRM&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;improvements&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;signed&lt;/li&gt;
&lt;li&gt;process(all)&lt;/li&gt;
&lt;li&gt;generate&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;"putting a lipstick on a pig"&lt;/p&gt;
&lt;h3&gt;new developments&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TL-Verilog&lt;/li&gt;
&lt;li&gt;SystemC/TLM&lt;/li&gt;
&lt;li&gt;"good tools are proprierty" (Vivado HLS, Catapult)&lt;/li&gt;
&lt;li&gt;Panda Bamboo&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GAUT (gaut.fr)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MyHDL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Chisel/SpinalHDL --&amp;gt; "going in the right direction" --&amp;gt; first need to learn Scala&lt;/li&gt;
&lt;li&gt;Migen/MiSoc/nmigen --&amp;gt; prefered by the speaker&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Python&lt;/h1&gt;
&lt;h2&gt;CPython Memory Management&lt;/h2&gt;
&lt;h3&gt;motivation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;what user needs to know&lt;/li&gt;
&lt;li&gt;learn how to control (gc, sys.getrefcount)&lt;/li&gt;
&lt;li&gt;memory leaks &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;allocation of memory&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CPython has PyObject for everything&lt;/li&gt;
&lt;li&gt;size: obj size &amp;lt; 512 bytes --&amp;gt; small, ele big&lt;/li&gt;
&lt;li&gt;big objects: system allocator&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;small object: 3 levels, pools and arena&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;8-byte alignment --&amp;gt; size idx: size / 8 - 1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;pools&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;4k size, objects of same size&lt;/li&gt;
&lt;li&gt;blocks &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;arenas&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;encapsulate pools&lt;/li&gt;
&lt;li&gt;containts 64 pools&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;object specificts&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;string interning (simple string)&lt;/li&gt;
&lt;li&gt;small integers (-5 to 256)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;garbage collection&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;reference counting&lt;/li&gt;
&lt;li&gt;easy to find unused obj&lt;/li&gt;
&lt;li&gt;no marking&lt;/li&gt;
&lt;li&gt;memory overhead&lt;/li&gt;
&lt;li&gt;no cyclical references&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;tools in python&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;two modules: gc and tracemalloc&lt;/li&gt;
&lt;li&gt;plus: sys._debugmallocstats()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;That's all folks, 'till next year!&lt;/em&gt;&lt;/p&gt;&lt;script src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;</content><category term="Conferences"></category><category term="Quantum computers"></category><category term="Open Hardware"></category><category term="Chisel"></category></entry></feed>